{"version":3,"sources":["webpack:///./shared/components/hero/assets/utils/DrawSVGPlugin.js","webpack:///./shared/components/hero/VideoControls.js","webpack:///./shared/components/hero/Video.js","webpack:///./shared/components/hero/assets/utils/MorphSVGPlugin.js"],"names":["DrawSVGPlugin","_doc","_gsScope","document","_computedStyleScope","window","defaultView","getComputedStyle","_getComputedStyle","e","_numbersExp","_isEdge","navigator","userAgent","indexOf","_types","rect","circle","ellipse","line","getDistance","x1","y1","x2","y2","scaleX","scaleY","parseFloat","Math","sqrt","unwrap","element","nodeType","TweenLite","selector","length","getLength","bbox","points","prevPoint","i","rx","ry","type","tagName","toLowerCase","getAttribute","getScreenCTM","a","b","d","c","getBBox","console","log","width","height","x","y","abs","style","strokeDasharray","getTotalLength","match","push","PI","getPosition","cs","dash","offset","strokeDashoffset","substr","max","_gsDefine","plugin","propName","API","version","global","overwriteProps","init","target","value","tween","index","start","end","overage","this","_style","_target","defaultStart","s","undefined","parse","_length","_dash","_offset","_offsetPT","_addTween","_dashPT","strokeLinecap","strokeLinejoin","strokeMiterlimit","_live","set","ratio","_firstPT","lengthRatio","_super","setRatio","call","VideoControls","require","props","videoControlsWrapper","createRef","whiteCircle","progressCircle","hitArea","playButton","playText","pauseButton","pauseText","videoControls","draggable","progressCirclePath","timeRanges","showControls","hideControls","intervalId","initTimeRanges","bind","seekVideo","playVideo","onDragEndPlay","setProgress","handleVideoControlsMouseEnter","handleVideoControlsMouseLeave","handleVidControlWrapperEnter","handleVidControlWrapperLeave","animateControlButton","handleControlButtonMouseEnter","handleControlButtonMouseLeave","updateControlVisibility","state","dragging","svgWrapperHover","progressCircleTl","TimelineMax","paused","hoverTl","hoverVidControlWrapperTl","playPauseSwapTl","hoverPlayButtonTl","hoverPauseButtonTl","MorphSVGPlugin","convertToPath","current","TweenMax","rotation","svgOrigin","autoAlpha","Draggable","create","bounds","minRotation","maxRotation","onDrag","onDragEnd","from","drawSVG","ease","to","attr","r","fromTo","css","opacity","prevProps","prevState","snapshot","timeLineProgress","NaN","progress","videoPlaying","play","reverse","mousePosOnVid","ref","className","onMouseEnter","onMouseLeave","xmlns","viewBox","cx","cy","stroke","stroke-width","fill","onMouseOver","onMouseOut","onClick","class","clearInterval","setState","getVideoTimeRange","percent","setPercent","el","scale","transformOrigin","timer","setInterval","setTimeout","Component","Video","video","provideVideoTimeRange","videoPlayStatus","updateTimeLineProgress","updateVideoCurrentTime","handlePlay","handleVideoPlayEnded","handleMouseEnter","handleMouseLeave","handleMouseMove","handleMouseMoveThrottled","_throttle","mouseHovering","mousePos","addEventListener","ticker","removeEventListener","content","caption","poster","src","onPlay","onMouseMove","onEnded","mouseHoveringVideo","timeRangesObject","seekable","count","bool","pause","currentTime","duration","clientX","clientY","_lastLinkedAnchor","_PI","_DEG2RAD","_svgPathExp","_selectorExp","_commands","_scientific","_atan2","atan2","_cos","cos","_sin","sin","_sqrt","_2PI","_angleMin","_angleMax","globals","_log","message","_arcToBeziers","lastX","lastY","angle","largeArcFlag","sweepFlag","angleRad","cosAngle","sinAngle","dx2","dy2","x1_sq","y1_sq","radiiCheck","rx_sq","ry_sq","sq","coef","cx1","cy1","ux","uy","vx","vy","temp","angleStart","acos","angleExtent","isNaN","segments","ceil","rawPath","angleIncrement","controlLength","ma","mb","mc","md","_stringToRawPath","j","command","isRelative","segment","startX","startY","difX","difY","beziers","prevCommand","replace","m","n","path","relativeX","relativeY","elements","errorMessage","sx","sy","ex","ey","toUpperCase","closed","pop","totalPoints","_subdivideSegment","quantity","ax","ay","cp1x","cp1y","cp2x","cp2y","bx","by","t","tally","l","newPointsPerSegment","floor","splice","_rawPathToString","precision","rnd","pow","_reverseBezier","reversed","_getAverageXY","_getSize","xMax","xMin","yMax","yMin","centerX","centerY","size","_getTotalSize","samplesPerBezier","k","inv","x3","x4","y3","y4","inc","left","top","_sortByComplexity","_sortBySize","sizeA","sizeB","_offsetSegment","shapeIndex","slice","wrap","_getTotalMovement","sb","eb","offsetX","offsetY","_getClosestShapeIndex","checkReverse","copy","sCenter","eCenter","min","minIndex","_getClosestAnchor","dx","dy","closestDistance","closestX","closestY","_getClosestSegment","bezier","pool","startIndex","sortRatio","minSize","_equalizeSegmentQuantity","map","fillSafe","dif","longer","shorter","added","sortMethod","shapeIndices","sort","join","_equalizePointQuantity","factor","nextX","nextY","toFixed","_pointsFilter","startNums","endNums","_buildPointsFilter","text","parseInt","_offsetPoints","_typeAttrs","_convertToPath","swap","data","rcirc","rycirc","w","h","x5","x6","y5","y6","circ","ignore","name","createElementNS","Array","prototype","attributes","nodeName","setAttributeNS","nodeValue","_createPath","attrs","split","obj","_attrToObj","shift","setAttribute","_gsRawPath","parentNode","insertBefore","removeChild","_parseShape","shape","forcePath","isString","test","getAttributeNS","_populateSmoothData","tolerance","smooth","a2","isSmooth","smoothData","limit","_parseOriginFactors","v","trim","_morphMessage","p","pt","isPoly","startSmooth","endSmooth","startSeg","endSeg","precompiled","sData","eData","originFactors","useRotation","fillRule","origins","origin","prop","defaultMap","_prop","_render","render","defaultRender","_apply","updateTarget","defaultUpdateTarget","_rnd","_tween","precompile","defaultType","smoothTolerance","_origin","_eOrigin","_rawPath","_controlPT","_next","l1s","l1c","l2s","l2c","_tweenRotation","_overwriteProps","endProp","easeInOut","controlPT","anchorPT","_anchorPT","sa","ca","sl","cl","linkedPT","angleDif","short","so","eo","pathFilter","pointsFilter","getTotalSize","subdivideRawBezier","subdivideSegment","rawPathToString","stringToRawPath","pathDataToRawBezier","equalizeSegmentQuantity","targets","pathDataToBezier","vars","matrix","prefix","align","relative"],"mappings":"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","file":"27.6813857c.js","sourcesContent":["/*!\n * VERSION: 0.2.1\n * DATE: 2019-02-07\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.\n * DrawSVGPlugin is a Club GreenSock membership benefit; You must have a valid membership to use\n * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.\n * This work is subject to the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n */\n/* eslint-disable */\n\nimport { _gsScope } from \"gsap/TweenLite.js\";\n\nvar _doc = _gsScope.document,\n\t\t_computedStyleScope = (typeof(window) !== \"undefined\" ? window : _doc.defaultView || {getComputedStyle:function() {}}),\n\t\t_getComputedStyle = function(e) {\n\t\t\treturn _computedStyleScope.getComputedStyle(e); //to avoid errors in Microsoft Edge, we need to call getComputedStyle() from a specific scope, typically window.\n\t\t},\n\t\t_numbersExp = /(?:(-|-=|\\+=)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t\t_isEdge = (((_gsScope.navigator || {}).userAgent || \"\").indexOf(\"Edge\") !== -1), //Microsoft Edge has a bug that causes it not to redraw the path correctly if the stroke-linecap is anything other than \"butt\" (like \"round\") and it doesn't match the stroke-linejoin. A way to trigger it is to change the stroke-miterlimit, so we'll only do that if/when we have to (to maximize performance)\n\t\t_types = {rect:[\"width\",\"height\"], circle:[\"r\",\"r\"], ellipse:[\"rx\",\"ry\"], line:[\"x2\",\"y2\"]},\n\t\tDrawSVGPlugin;\n\n\tfunction getDistance(x1, y1, x2, y2, scaleX, scaleY) {\n\t\tx2 = (parseFloat(x2 || 0) - parseFloat(x1 || 0)) * scaleX;\n\t\ty2 = (parseFloat(y2 || 0) - parseFloat(y1 || 0)) * scaleY;\n\t\treturn Math.sqrt(x2 * x2 + y2 * y2);\n\t}\n\n\tfunction unwrap(element) {\n\t\tif (typeof(element) === \"string\" || !element.nodeType) {\n\t\t\telement = _gsScope.TweenLite.selector(element);\n\t\t\tif (element.length) {\n\t\t\t\telement = element[0];\n\t\t\t}\n\t\t}\n\t\treturn element;\n\t}\n\n\t//accepts values like \"100%\" or \"20% 80%\" or \"20 50\" and parses it into an absolute start and end position on the line/stroke based on its length. Returns an an array with the start and end values, like [0, 243]\n\tfunction parse(value, length, defaultStart) {\n\t\tvar i = value.indexOf(\" \"),\n\t\t\ts, e;\n\t\tif (i === -1) {\n\t\t\ts = defaultStart !== undefined ? defaultStart + \"\" : value;\n\t\t\te = value;\n\t\t} else {\n\t\t\ts = value.substr(0, i);\n\t\t\te = value.substr(i+1);\n\t\t}\n\t\ts = (s.indexOf(\"%\") !== -1) ? (parseFloat(s) / 100) * length : parseFloat(s);\n\t\te = (e.indexOf(\"%\") !== -1) ? (parseFloat(e) / 100) * length : parseFloat(e);\n\t\treturn (s > e) ? [e, s] : [s, e];\n\t}\n\n\tfunction getLength(element) {\n\t\tif (!element) {\n\t\t\treturn 0;\n\t\t}\n\t\telement = unwrap(element);\n\t\tvar type = element.tagName.toLowerCase(),\n\t\t\tscaleX = 1,\n\t\t\tscaleY = 1,\n\t\t\tlength, bbox, points, prevPoint, i, rx, ry;\n\t\tif (element.getAttribute(\"vector-effect\") === \"non-scaling-stroke\") { //non-scaling-stroke basically scales the shape and then strokes it at the screen-level (after transforms), thus we need to adjust the length accordingly.\n\t\t\tscaleY = element.getScreenCTM();\n\t\t\tscaleX = Math.sqrt(scaleY.a * scaleY.a + scaleY.b * scaleY.b);\n\t\t\tscaleY = Math.sqrt(scaleY.d * scaleY.d + scaleY.c * scaleY.c);\n\t\t}\n\t\ttry { //IE bug: calling <path>.getTotalLength() locks the repaint area of the stroke to whatever its current dimensions are on that frame/tick. To work around that, we must call getBBox() to force IE to recalculate things.\n\t\t\tbbox = element.getBBox(); //solely for fixing bug in IE - we don't actually use the bbox.\n\t\t} catch (e) {\n\t\t\t//firefox has a bug that throws an error if the element isn't visible.\n\t\t\tconsole.log(\"Error: Some browsers like Firefox won't report measurements of invisible elements (like display:none or masks inside defs).\");\n\t\t}\n\t\tif ((!bbox || (!bbox.width && !bbox.height)) && _types[type]) { //if the element isn't visible, try to discern width/height using its attributes.\n\t\t\tbbox = {\n\t\t\t\twidth: parseFloat( element.getAttribute(_types[type][0]) ),\n\t\t\t\theight: parseFloat( element.getAttribute(_types[type][1]) )\n\t\t\t};\n\t\t\tif (type !== \"rect\" && type !== \"line\") { //double the radius for circles and ellipses\n\t\t\t\tbbox.width *= 2;\n\t\t\t\tbbox.height *= 2;\n\t\t\t}\n\t\t\tif (type === \"line\") {\n\t\t\t\tbbox.x = parseFloat( element.getAttribute(\"x1\") );\n\t\t\t\tbbox.y = parseFloat( element.getAttribute(\"y1\") );\n\t\t\t\tbbox.width = Math.abs(bbox.width - bbox.x);\n\t\t\t\tbbox.height = Math.abs(bbox.height - bbox.y);\n\t\t\t}\n\t\t}\n\t\tif (type === \"path\") {\n\t\t\tprevPoint = element.style.strokeDasharray;\n\t\t\telement.style.strokeDasharray = \"none\";\n\t\t\tlength = element.getTotalLength() || 0;\n\t\t\tif (scaleX !== scaleY) {\n\t\t\t\tconsole.log(\"Warning: <path> length cannot be measured accurately when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.\");\n\t\t\t}\n\t\t\tlength *= (scaleX + scaleY) / 2;\n\t\t\telement.style.strokeDasharray = prevPoint;\n\t\t} else if (type === \"rect\") {\n\t\t\tlength = bbox.width * 2 * scaleX + bbox.height * 2 * scaleY;\n\t\t} else if (type === \"line\") {\n\t\t\tlength = getDistance(bbox.x, bbox.y, bbox.x + bbox.width, bbox.y + bbox.height, scaleX, scaleY);\n\t\t} else if (type === \"polyline\" || type === \"polygon\") {\n\t\t\tpoints = element.getAttribute(\"points\").match(_numbersExp) || [];\n\t\t\tif (type === \"polygon\") {\n\t\t\t\tpoints.push(points[0], points[1]);\n\t\t\t}\n\t\t\tlength = 0;\n\t\t\tfor (i = 2; i < points.length; i+=2) {\n\t\t\t\tlength += getDistance(points[i-2], points[i-1], points[i], points[i+1], scaleX, scaleY) || 0;\n\t\t\t}\n\t\t} else if (type === \"circle\" || type === \"ellipse\") {\n\t\t\trx = (bbox.width / 2) * scaleX;\n\t\t\try = (bbox.height / 2) * scaleY;\n\t\t\tlength = Math.PI * ( 3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)) );\n\t\t}\n\t\treturn length || 0;\n\t}\n\n\tfunction getPosition(element, length) {\n\t\tif (!element) {\n\t\t\treturn [0, 0];\n\t\t}\n\t\telement = unwrap(element);\n\t\tlength = length || (getLength(element) + 1);\n\t\tvar cs = _getComputedStyle(element),\n\t\t\tdash = cs.strokeDasharray || \"\",\n\t\t\toffset = parseFloat(cs.strokeDashoffset),\n\t\t\ti = dash.indexOf(\",\");\n\t\tif (i < 0) {\n\t\t\ti = dash.indexOf(\" \");\n\t\t}\n\t\tdash = (i < 0) ? length : parseFloat(dash.substr(0, i)) || 0.00001;\n\t\tif (dash > length) {\n\t\t\tdash = length;\n\t\t}\n\t\treturn [Math.max(0, -offset), Math.max(0, dash - offset)];\n\t}\n\n\tDrawSVGPlugin = _gsScope._gsDefine.plugin({\n\t\tpropName: \"drawSVG\",\n\t\tAPI: 2,\n\t\tversion: \"0.2.1\",\n\t\tglobal: true,\n\t\toverwriteProps: [\"drawSVG\"],\n\n\t\tinit: function(target, value, tween, index) {\n\t\t\tif (!target.getBBox) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar length = getLength(target) + 1,\n\t\t\t\tstart, end, overage, cs;\n\t\t\tthis._style = target.style;\n\t\t\tthis._target = target;\n\t\t\tif (typeof(value) === \"function\") {\n\t\t\t\tvalue = value(index, target);\n\t\t\t}\n\t\t\tif (value === true || value === \"true\") {\n\t\t\t\tvalue = \"0 100%\";\n\t\t\t} else if (!value) {\n\t\t\t\tvalue = \"0 0\";\n\t\t\t} else if ((value + \"\").indexOf(\" \") === -1) {\n\t\t\t\tvalue = \"0 \" + value;\n\t\t\t}\n\t\t\tstart = getPosition(target, length);\n\t\t\tend = parse(value, length, start[0]);\n\t\t\tthis._length = length + 10;\n\t\t\tif (start[0] === 0 && end[0] === 0) {\n\t\t\t\toverage = Math.max(0.00001, end[1] - length); //allow people to go past the end, like values of 105% because for some paths, Firefox doesn't return an accurate getTotalLength(), so it could end up coming up short.\n\t\t\t\tthis._dash = length + overage;\n\t\t\t\tthis._offset = length - start[1] + overage;\n\t\t\t\tthis._offsetPT = this._addTween(this, \"_offset\", this._offset, length - end[1] + overage, \"drawSVG\");\n\t\t\t} else {\n\t\t\t\tthis._dash = (start[1] - start[0]) || 0.000001; //some browsers render artifacts if dash is 0, so we use a very small number in that case.\n\t\t\t\tthis._offset = -start[0];\n\t\t\t\tthis._dashPT = this._addTween(this, \"_dash\", this._dash, (end[1] - end[0]) || 0.00001, \"drawSVG\");\n\t\t\t\tthis._offsetPT = this._addTween(this, \"_offset\", this._offset, -end[0], \"drawSVG\");\n\t\t\t}\n\t\t\tif (_isEdge) { //to work around a bug in Microsoft Edge, animate the stroke-miterlimit by 0.0001 just to trigger the repaint (unnecessary if it's \"round\" and stroke-linejoin is also \"round\"). Imperceptible, relatively high-performance, and effective. Another option was to set the \"d\" <path> attribute to its current value on every tick, but that seems like it'd be much less performant.\n\t\t\t\tcs = _getComputedStyle(target);\n\t\t\t\tif (cs.strokeLinecap !== cs.strokeLinejoin) {\n\t\t\t\t\tend = parseFloat(cs.strokeMiterlimit);\n\t\t\t\t\tthis._addTween(target.style, \"strokeMiterlimit\", end, end + 0.0001, \"strokeMiterlimit\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._live = (target.getAttribute(\"vector-effect\") === \"non-scaling-stroke\" || (value + \"\").indexOf(\"live\") !== -1);\n\t\t\treturn true;\n\t\t},\n\n\t\t//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)\n\t\tset: function(ratio) {\n\t\t\tif (this._firstPT) {\n\t\t\t\t//when the element has vector-effect=\"non-scaling-stroke\" and the SVG is resized (like on a window resize), it actually changes the length of the stroke! So we must sense that and make the proper adjustments.\n\t\t\t\tif (this._live) {\n\t\t\t\t\tvar length = getLength(this._target) + 11,\n\t\t\t\t\t\tlengthRatio;\n\t\t\t\t\tif (length !== this._length) {\n\t\t\t\t\t\tlengthRatio = length / this._length;\n\t\t\t\t\t\tthis._length = length;\n\t\t\t\t\t\tthis._offsetPT.s *= lengthRatio;\n\t\t\t\t\t\tthis._offsetPT.c *= lengthRatio;\n\t\t\t\t\t\tif (this._dashPT) {\n\t\t\t\t\t\t\tthis._dashPT.s *= lengthRatio;\n\t\t\t\t\t\t\tthis._dashPT.c *= lengthRatio;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._dash *= lengthRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._super.setRatio.call(this, ratio);\n\t\t\t\tthis._style.strokeDashoffset = this._offset;\n\t\t\t\tif (ratio === 1 || ratio === 0) {\n\t\t\t\t\tthis._style.strokeDasharray = (this._offset < 0.001 && this._length - this._dash <= 10) ? \"none\" : (this._offset === this._dash) ? \"0px, 999999px\" : this._dash + \"px,\" + this._length + \"px\";\n\t\t\t\t} else {\n\t\t\t\t\tthis._style.strokeDasharray = this._dash + \"px,\" + this._length + \"px\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t});\n\n\tDrawSVGPlugin.getLength = getLength;\n\tDrawSVGPlugin.getPosition = getPosition;\n\nexport { DrawSVGPlugin, DrawSVGPlugin as default };","import React, { Component, createRef } from 'react';\nimport './assets/css/video-controls.css';\nimport _throttle from 'lodash/throttle';\nimport _debounce from 'lodash/debounce';\n\nif (process.env.IS_BROWSER) {\n  const TweenMax = require('gsap/TweenMax');\n  const TimelineMax = require('gsap/TimelineMax');\n  const AttrPlugin = require('gsap/AttrPlugin');\n  const Draggable = require('gsap/Draggable');\n  const MorphSVGPlugin = require('./assets/utils/MorphSVGPlugin');\n  const DrawSVGPlugin = require('./assets/utils/DrawSVGPlugin');\n}\n\nexport default class VideoControls extends Component {\n\n  constructor(props) {\n    super(props);\n\n    this.videoControlsWrapper = createRef();\n    this.whiteCircle = createRef();\n    this.progressCircle = createRef();\n    this.hitArea = createRef();\n    this.playButton = createRef();\n    this.playText = createRef();\n    this.pauseButton = createRef();\n    this.pauseText = createRef();\n    this.videoControls = createRef();\n\n    this.draggable;\n    this.progressCirclePath;\n    this.timeRanges;\n    this.showControls;\n    this.hideControls;\n    this.intervalId = 0;\n\n    this.initTimeRanges = this.initTimeRanges.bind(this);\n    this.seekVideo = this.seekVideo.bind(this);\n    this.playVideo = this.playVideo.bind(this);\n    this.onDragEndPlay = this.onDragEndPlay.bind(this);\n    this.setProgress = this.setProgress.bind(this);\n    this.handleVideoControlsMouseEnter = this.handleVideoControlsMouseEnter.bind(this);\n    this.handleVideoControlsMouseLeave = this.handleVideoControlsMouseLeave.bind(this);\n    this.handleVidControlWrapperEnter = this.handleVidControlWrapperEnter.bind(this);\n    this.handleVidControlWrapperLeave = this.handleVidControlWrapperLeave.bind(this);\n\n    this.animateControlButton = this.animateControlButton.bind(this);\n    this.handleControlButtonMouseEnter = this.handleControlButtonMouseEnter.bind(this);\n    this.handleControlButtonMouseLeave = this.handleControlButtonMouseLeave.bind(this);\n    this.updateControlVisibility = this.updateControlVisibility.bind(this);\n\n    this.state = {\n      dragging: false,\n      timeRanges: null,\n      svgWrapperHover: false\n    };\n\n  }\n\n  componentDidMount() {\n\n    if (process.env.IS_BROWSER) {\n\n      this.progressCircleTl = new TimelineMax({ paused: true });\n      this.hoverTl = new TimelineMax({ paused: true });\n\n      this.hoverVidControlWrapperTl = new TimelineMax({ paused: true });\n\n      this.playPauseSwapTl = new TimelineMax({ paused: true });\n      this.hoverPlayButtonTl = new TimelineMax({ paused: true });\n      this.hoverPauseButtonTl = new TimelineMax({ paused: true });\n\n        this.progressCirclePath = MorphSVGPlugin.convertToPath(this.progressCircle.current);\n\n        TweenMax.set(this.videoControls.current, { rotation: 0, svgOrigin: \"150, 150\" });\n        TweenMax.set(this.pauseButton.current, { autoAlpha: 0 });\n\n        this.draggable = Draggable.create(this.videoControls.current, {\n          type: \"rotation\",\n          bounds: { minRotation: 0, maxRotation: 360 },\n          onDrag: this.seekVideo,\n          onDragEnd: this.onDragEndPlay\n        });\n\n        this.progressCircleTl\n          .from(this.progressCirclePath, 0.5, { drawSVG: \"0%\", ease: \"Power0.easeNone\" })\n          .to(this.videoControls.current, 0.5, { rotation: 360, ease: \"Power0.easeNone\" }, 0);\n\n        this.hoverTl\n         .to(this.videoControls.current, 0.5, { attr: { r: 8 } });\n\n        this.playPauseSwapTl\n          .fromTo(this.playButton.current, 0.5, { autoAlpha: 1 }, { autoAlpha: 0 })\n          .fromTo(this.pauseButton.current, 0.5, { autoAlpha: 0 }, { autoAlpha: 1 }, 0);\n\n        this.hoverVidControlWrapperTl\n          .to([this.videoControls.current, this.hitArea.current], 0.5, { attr: { r: 6 } })\n          .fromTo(this.whiteCircle.current, 0.5, { css: { opacity: 0.25 } }, { css: { opacity: 1 } }, 0)\n\n        this.showControls = () => TweenMax.to([this.videoControlsWrapper.current, this.hitArea.current], 3, { css: {opacity: 1} });\n        this.hideControls = () => TweenMax.to([this.videoControlsWrapper.current, this.hitArea.current], 3, { css: {opacity: 0} });\n\n    }\n\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    if (process.env.IS_BROWSER) {\n      if ( (prevProps.timeLineProgress !== this.props.timeLineProgress) && this.props.timeLineProgress !== NaN ) {\n        this.progressCircleTl.progress( this.props.timeLineProgress );\n      }\n\n      if (prevProps.videoPlaying !== this.props.videoPlaying) { // this is only going to fire once, when the video changes state from playing to paused and vice versa\n        if (this.props.videoPlaying) {\n          this.playPauseSwapTl.play();\n        } else {\n          this.showControls();\n          this.playPauseSwapTl.reverse();\n        }\n      }\n\n      if (prevProps.mousePosOnVid !== this.props.mousePosOnVid) {\n        if (this.props.videoPlaying) { this.updateControlVisibility(); }\n      }\n    }\n  }\n\n\n  render() {\n\n    const playPauseText = () => !this.props.videoPlaying ? <span ref={ this.playText }>PLAY</span> : <span ref={ this.pauseText }>PAUSE</span>;\n\n\n    return (\n      <>\n      <div ref={ this.videoControlsWrapper } className=\"video-controls-wrapper\" onMouseEnter={ this.handleVidControlWrapperEnter } onMouseLeave={ this.handleVidControlWrapperLeave }>\n      <svg className=\"video-controls\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 300 300\">\n\n        <circle ref={ this.whiteCircle } className=\"st0\" cx=\"150\" cy=\"150\" r=\"75\" />\n        <circle ref={ this.progressCircle } stroke=\"green\" stroke-width=\"3\" fill=\"none\" cx=\"150\" cy=\"150\" r=\"75\"  />\n        <circle ref={ this.videoControls } className=\"video-controls-component\" stroke=\"green\" stroke-width=\"1\" fill=\"green\" cx=\"225\" cy=\"150\" r=\"4\" onMouseOver={ this.handleVideoControlsMouseEnter } onMouseOut={ this.handleVideoControlsMouseLeave } />\n\n      </svg>\n\n        { this.state.dragging === false ? <p onClick={ this.playVideo }>{ playPauseText() } VIDEO</p> : <p>SEEKING</p> }\n      </div>\n\n      <div className=\"hit-area\" ref={ this.hitArea } onMouseEnter={ this.handleControlButtonMouseEnter } onMouseLeave={ this.handleControlButtonMouseLeave } onClick={ this.playVideo }>\n\n        <svg className=\"video-controls-play-button\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"-20 -20 200 200\">\n        <g className=\"button\" ref={ this.playButton }>\n          <polygon class=\"st0\" points=\"16.85,20.41 15.73,13.06 25.75,20.41 15.73,27.76 \t\"/>\n          <path class=\"st0\" d=\"M16.41,14.18l8.5,6.23l-8.5,6.23l0.92-6.08l0.02-0.15l-0.02-0.15L16.41,14.18 M15.06,11.95l1.28,8.46l-1.28,8.46l11.54-8.46L15.06,11.95L15.06,11.95z\"/>\n        </g>\n\n        <g className=\"button\" ref={ this.pauseButton }>\n          <g>\n            <rect x=\"13.1\" y=\"10.91\" class=\"st0\" width=\"4\" height=\"19\"/>\n            <path class=\"st0\" d=\"M16.6,11.41v18h-3v-18H16.6 M17.6,10.41h-5v20h5V10.41L17.6,10.41z\"/>\n          </g>\n          <g>\n            <rect x=\"21.86\" y=\"10.91\" class=\"st0\" width=\"4\" height=\"19\"/>\n            <path class=\"st0\" d=\"M25.36,11.41v18h-3v-18H25.36 M26.36,10.41h-5v20h5V10.41L26.36,10.41z\"/>\n          </g>\n        </g>\n        </svg>\n      </div>\n      </>\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.intervalId);\n  }\n\n  initTimeRanges() {\n    this.setState({ timeRanges: this.props.getVideoTimeRange() });\n  }\n\n  playVideo() {\n    this.state.timeRanges === null ? this.initTimeRanges() : null;\n    this.props.playVideo(!this.props.videoPlaying);\n  }\n\n  onDragEndPlay() {\n    this.props.playVideo(true);\n    this.setState({ dragging: false });\n  }\n\n  seekVideo() {\n    this.playVideo();\n    this.setProgress( this.draggable[0].rotation / 360 );\n    this.setState({ dragging: true });\n  }\n\n  setProgress(percent) {\n    this.props.setPercent(percent);\n  }\n\n  handleVideoControlsMouseEnter() {\n    this.hoverTl.play();\n  }\n\n  handleVideoControlsMouseLeave() {\n    this.hoverTl.reverse();\n  }\n\n  handleVidControlWrapperEnter() {\n    this.hoverVidControlWrapperTl.play();\n    this.showControls();\n    this.setState({ svgWrapperHover: true });\n  }\n\n  handleVidControlWrapperLeave() {\n    this.hoverVidControlWrapperTl.reverse();\n    this.setState({ svgWrapperHover: false });\n  }\n\n  animateControlButton(el) {\n    return this.hoverPlayButtonTl.to(el.current, 0.5, { css: { scale: 1.75, transformOrigin: \"center center\" } });\n  }\n\n  handleControlButtonMouseEnter() {\n    let el = this.props.videoPlaying ? this.pauseButton : this.playButton;\n    this.animateControlButton(el).play();\n    this.showControls();\n    this.setState({ svgWrapperHover: true });\n  }\n\n  handleControlButtonMouseLeave() {\n    let el = this.props.videoPlaying ? this.pauseButton : this.playButton;\n    this.animateControlButton(el).reverse();\n    this.setState({ svgWrapperHover: false });\n  }\n\n  updateControlVisibility() {\n    var timer = 3;\n    this.showControls();\n\n    this.intervalId = setInterval(\n      () => {\n        if (timer > 0) {\n          timer = timer - 1;\n        }\n      },\n    1000);\n\n    setTimeout(\n      () => {\n        clearInterval(this.intervalId);\n        if (this.props.videoPlaying && !this.state.svgWrapperHover) {\n          this.hideControls();\n        } else {\n          this.showControls()\n        }\n      },\n    3500);\n\n  }\n\n};\n","import React, { Component, createRef } from 'react';\nimport VideoControls from './VideoControls';\nimport _throttle from 'lodash/throttle';\n\nif (process.env.IS_BROWSER) {\n  const TweenLite = require('gsap/TweenLite');\n}\n\nexport default class Video extends Component {\n\n  constructor(props) {\n    super(props);\n\n    this.timeRanges = [];\n    this.video = createRef();\n\n    this.provideVideoTimeRange = this.provideVideoTimeRange.bind(this);\n    this.videoPlayStatus = this.videoPlayStatus.bind(this);\n    this.updateTimeLineProgress = this.updateTimeLineProgress.bind(this);\n    this.updateVideoCurrentTime = this.updateVideoCurrentTime.bind(this);\n    this.handlePlay = this.handlePlay.bind(this);\n    this.handleVideoPlayEnded = this.handleVideoPlayEnded.bind(this);\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n\n    this.handleMouseMoveThrottled = _throttle(this.handleMouseMove, 1000, { 'leading': true, 'trailing': false });\n\n\n    this.state = {\n      timeLineProgress: 0,\n      mouseHovering: false,\n      videoPlaying: false,\n      mousePos: [0, 0]\n    };\n  }\n\n  componentDidMount() {\n    this.video.current.addEventListener('timeupdate', this.updateTimeLineProgress);\n  }\n\n  componentWillUnmount() {\n    TweenLite.ticker.removeEventListener('tick', this.updateTimeLineProgress);\n    this.video.current.removeEventListener('timeupdate', this.updateTimeLineProgress);\n  }\n\n  render() {\n    const { caption, poster, src } = this.props.content;\n\n    return (\n      <>\n        <video ref={ this.video } poster={poster} onPlay={ this.handlePlay } onMouseEnter={ this.handleMouseEnter } onMouseLeave={ this.handleMouseLeave } onMouseMove={ this.handleMouseMoveThrottled } onEnded={ this.handleVideoPlayEnded }>\n          <source src={src} />\n        </video>\n        <VideoControls\n          getVideoTimeRange={ this.provideVideoTimeRange }\n          playVideo={ this.videoPlayStatus }\n          videoPlaying={ this.state.videoPlaying }\n          mouseHoveringVideo={ this.state.mouseHovering }\n          timeLineProgress={ this.state.timeLineProgress }\n          setPercent={ this.updateVideoCurrentTime }\n          mousePosOnVid={ this.state.mousePos }\n        />\n        <span className=\"vid-time\">00:00</span>\n        <p>{caption}</p>\n      </>\n    );\n  }\n\n  handlePlay() {\n    TweenLite.ticker.addEventListener('tick', this.updateTimeLineProgress);\n  }\n\n  provideVideoTimeRange() {\n    const timeRangesObject = this.video.current.seekable;\n    for (let count = 0; count < timeRangesObject.length; count++) {\n      this.timeRanges.push([timeRangesObject.start(count), timeRangesObject.end(count)]);\n    }\n    return this.timeRanges;\n  }\n\n  videoPlayStatus(bool) {\n    if (bool) {\n      this.video.current.play();\n      this.setState({ videoPlaying: true });\n    } else {\n      this.video.current.pause();\n      this.setState({ videoPlaying: false });\n    }\n  }\n\n  updateTimeLineProgress() {\n    this.setState({ timeLineProgress: (this.video.current.currentTime / this.video.current.duration) });\n  }\n\n  updateVideoCurrentTime(percent) {\n    this.video.current.currentTime = ( this.timeRanges[0][1] * percent );\n  }\n\n  handleVideoPlayEnded() {\n    this.setState({ videoPlaying: false });\n  }\n\n  handleMouseEnter() {\n    this.setState({ mouseHovering: true });\n  }\n\n  handleMouseLeave() {\n    this.setState({ mouseHovering: false });\n  }\n\n\n  handleMouseMove(e) {\n    if (e.clientX !== null && e.clientY !== null) {\n      this.setState({ mousePos: [e.clientX, e.clientY] });\n    }\n  }\n\n};\n","/*!\n * VERSION: 0.9.2\n * DATE: 2019-08-13\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.\n * MorphSVGPlugin is a Club GreenSock membership benefit; You must have a valid membership to use\n * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.\n * This work is subject to the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n */\n/* eslint-disable */\n\nimport { _gsScope } from \"gsap/TweenLite.js\";\n\n\tvar _PI = Math.PI,\n\t\t_DEG2RAD = _PI / 180,\n\t\t_svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t\t_numbersExp = /(?:(-|-=|\\+=)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t\t_selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i,\n\t\t_commands = /[achlmqstvz]/ig,\n\t\t_scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig,\n\t\t_atan2 = Math.atan2,\n\t\t_cos = Math.cos,\n\t\t_sin = Math.sin,\n\t\t_sqrt = Math.sqrt,\n\t\t_2PI = _PI * 2,\n\t\t_angleMin = _PI * 0.3,\n\t\t_angleMax = _PI * 0.7,\n\t\t_bigNum = 1e20,\n\t\t_lastLinkedAnchor,\n\t\tTweenLite = _gsScope._gsDefine.globals.TweenLite,\n\n\t\t_log = function(message) {\n\t\t\tif (_gsScope.console) {\n\t\t\t\tconsole.log(message);\n\t\t\t}\n\t\t},\n\n\t\t// translates SVG arc data into an array of cubic beziers\n\t\t_arcToBeziers = function(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n\t\t\tif (lastX === x && lastY === y) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trx = Math.abs(rx);\n\t\t\try = Math.abs(ry);\n\t\t\tvar angleRad = (angle % 360) * _DEG2RAD,\n\t\t\t\tcosAngle = _cos(angleRad),\n\t\t\t\tsinAngle = _sin(angleRad),\n\t\t\t\tdx2 = (lastX - x) / 2,\n\t\t\t\tdy2 = (lastY - y) / 2,\n\t\t\t\tx1 = (cosAngle * dx2 + sinAngle * dy2),\n\t\t\t\ty1 = (-sinAngle * dx2 + cosAngle * dy2),\n\t\t\t\tx1_sq = x1 * x1,\n\t\t\t\ty1_sq = y1 * y1,\n\t\t\t\tradiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);\n\t\t\tif (radiiCheck > 1) {\n\t\t\t\trx = _sqrt(radiiCheck) * rx;\n\t\t\t\try = _sqrt(radiiCheck) * ry;\n\t\t\t}\n\t\t\tvar rx_sq = rx * rx,\n\t\t\t\try_sq = ry * ry,\n\t\t\t\tsq = ((rx_sq * ry_sq) - (rx_sq * y1_sq) - (ry_sq * x1_sq)) / ((rx_sq * y1_sq) + (ry_sq * x1_sq));\n\t\t\tif (sq < 0) {\n\t\t\t\tsq = 0;\n\t\t\t}\n\t\t\tvar coef = ((largeArcFlag === sweepFlag) ? -1 : 1) * _sqrt(sq),\n\t\t\t\tcx1 = coef * ((rx * y1) / ry),\n\t\t\t\tcy1 = coef * -((ry * x1) / rx),\n\t\t\t\tsx2 = (lastX + x) / 2,\n\t\t\t\tsy2 = (lastY + y) / 2,\n\t\t\t\tcx = sx2 + (cosAngle * cx1 - sinAngle * cy1),\n\t\t\t\tcy = sy2 + (sinAngle * cx1 + cosAngle * cy1),\n\t\t\t\tux = (x1 - cx1) / rx,\n\t\t\t\tuy = (y1 - cy1) / ry,\n\t\t\t\tvx = (-x1 - cx1) / rx,\n\t\t\t\tvy = (-y1 - cy1) / ry,\n\t\t\t\ttemp = ux * ux + uy * uy,\n\t\t\t\tangleStart = ((uy < 0) ? -1 : 1) * Math.acos(ux / _sqrt(temp)),\n\t\t\t\tangleExtent = ((ux * vy - uy * vx < 0) ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));\n\t\t\tif (isNaN(angleExtent)) { //rare edge case. Math.cos(-1) is NaN.\n\t\t\t\tangleExtent = _PI;\n\t\t\t}\n\t\t\tif (!sweepFlag && angleExtent > 0) {\n\t\t\t\tangleExtent -= _2PI;\n\t\t\t} else if (sweepFlag && angleExtent < 0) {\n\t\t\t\tangleExtent += _2PI;\n\t\t\t}\n\t\t\tangleStart %= _2PI;\n\t\t\tangleExtent %= _2PI;\n\t\t\tvar segments = Math.ceil(Math.abs(angleExtent) / (_2PI / 4)),\n\t\t\t\trawPath = [],\n\t\t\t\tangleIncrement = angleExtent / segments,\n\t\t\t\tcontrolLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),\n\t\t\t\tma = cosAngle * rx,\n\t\t\t\tmb = sinAngle * rx,\n\t\t\t\tmc = sinAngle * -ry,\n\t\t\t\tmd = cosAngle * ry,\n\t\t\t\ti;\n\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\tangle = angleStart + i * angleIncrement;\n\t\t\t\tx1 = _cos(angle);\n\t\t\t\ty1 = _sin(angle);\n\t\t\t\tux = _cos(angle += angleIncrement);\n\t\t\t\tuy = _sin(angle);\n\t\t\t\trawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);\n\t\t\t}\n\t\t\t//now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).\n\t\t\tfor (i = 0; i < rawPath.length; i+=2) {\n\t\t\t\tx1 = rawPath[i];\n\t\t\t\ty1 = rawPath[i+1];\n\t\t\t\trawPath[i] = x1 * ma + y1 * mc + cx;\n\t\t\t\trawPath[i+1] = x1 * mb + y1 * md + cy;\n\t\t\t}\n\t\t\trawPath[i-2] = x; //always set the end to exactly where it's supposed to be\n\t\t\trawPath[i-1] = y;\n\t\t\treturn rawPath;\n\t\t},\n\n\t\t//Spits back an array of cubic Bezier segments that use absolute coordinates. Each segment starts with a \"moveTo\" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.\n\t\t_stringToRawPath = function(d) {\n\t\t\tvar a = (d + \"\").replace(_scientific, function(m) { var n = +m; return (n < 0.0001 && n > -0.0001) ? 0 : n; }).match(_svgPathExp) || [], //some authoring programs spit out very small numbers in scientific notation like \"1e-5\", so make sure we round that down to 0 first.\n\t\t\t\tpath = [],\n\t\t\t\trelativeX = 0,\n\t\t\t\trelativeY = 0,\n\t\t\t\ttwoThirds = 2 / 3,\n\t\t\t\telements = a.length,\n\t\t\t\tpoints = 0,\n\t\t\t\terrorMessage = \"ERROR: malformed path: \" + d,\n\t\t\t\tline = function(sx, sy, ex, ey) {\n\t\t\t\t\tdifX = (ex - sx) / 3;\n\t\t\t\t\tdifY = (ey - sy) / 3;\n\t\t\t\t\tsegment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);\n\t\t\t\t},\n\t\t\t\ti, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand;\n\t\t\tif (!d || !isNaN(a[0]) || isNaN(a[1])) {\n\t\t\t\t_log(errorMessage);\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tfor (i = 0; i < elements; i++) {\n\t\t\t\tprevCommand = command;\n\t\t\t\tif (isNaN(a[i])) {\n\t\t\t\t\tcommand = a[i].toUpperCase();\n\t\t\t\t\tisRelative = (command !== a[i]); //lower case means relative\n\t\t\t\t} else { //commands like \"C\" can be strung together without any new command characters between.\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tx = +a[i + 1];\n\t\t\t\ty = +a[i + 2];\n\t\t\t\tif (isRelative) {\n\t\t\t\t\tx += relativeX;\n\t\t\t\t\ty += relativeY;\n\t\t\t\t}\n\t\t\t\tif (!i) {\n\t\t\t\t\tstartX = x;\n\t\t\t\t\tstartY = y;\n\t\t\t\t}\n\n\t\t\t\t// \"M\" (move)\n\t\t\t\tif (command === \"M\") {\n\t\t\t\t\tif (segment) {\n\t\t\t\t\t\tif (segment.length < 8) { //if the path data was funky and just had a M with no actual drawing anywhere, skip it.\n\t\t\t\t\t\t\tpath.length -= 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpoints += segment.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trelativeX = startX = x;\n\t\t\t\t\trelativeY = startY = y;\n\t\t\t\t\tsegment = [x, y];\n\t\t\t\t\tpath.push(segment);\n\t\t\t\t\ti += 2;\n\t\t\t\t\tcommand = \"L\"; //an \"M\" with more than 2 values gets interpreted as \"lineTo\" commands (\"L\").\n\n\t\t\t\t// \"C\" (cubic bezier)\n\t\t\t\t} else if (command === \"C\") {\n\t\t\t\t\tif (!segment) {\n\t\t\t\t\t\tsegment = [0, 0];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isRelative) {\n\t\t\t\t\t\trelativeX = relativeY = 0;\n\t\t\t\t\t}\n\t\t\t\t\t//note: \"*1\" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.\n\t\t\t\t\tsegment.push(x,\ty, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, (relativeX += a[i + 5] * 1),\t(relativeY += a[i + 6] * 1));\n\t\t\t\t\ti += 6;\n\n\t\t\t\t// \"S\" (continuation of cubic bezier)\n\t\t\t\t} else if (command === \"S\") {\n\t\t\t\t\tdifX = relativeX;\n\t\t\t\t\tdifY = relativeY;\n\t\t\t\t\tif (prevCommand === \"C\" || prevCommand === \"S\") {\n\t\t\t\t\t\tdifX += relativeX - segment[segment.length - 4];\n\t\t\t\t\t\tdifY += relativeY - segment[segment.length - 3];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isRelative) {\n\t\t\t\t\t\trelativeX = relativeY = 0;\n\t\t\t\t\t}\n\t\t\t\t\tsegment.push(difX, difY, x,\ty, (relativeX += a[i + 3] * 1), (relativeY += a[i + 4] * 1));\n\t\t\t\t\ti += 4;\n\n\t\t\t\t// \"Q\" (quadratic bezier)\n\t\t\t\t} else if (command === \"Q\") {\n\t\t\t\t\tdifX = relativeX + (x - relativeX) * twoThirds;\n\t\t\t\t\tdifY = relativeY + (y - relativeY) * twoThirds;\n\t\t\t\t\tif (!isRelative) {\n\t\t\t\t\t\trelativeX = relativeY = 0;\n\t\t\t\t\t}\n\t\t\t\t\trelativeX += a[i + 3] * 1;\n\t\t\t\t\trelativeY += a[i + 4] * 1;\n\t\t\t\t\tsegment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);\n\t\t\t\t\ti += 4;\n\n\t\t\t\t// \"T\" (continuation of quadratic bezier)\n\t\t\t\t} else if (command === \"T\") {\n\t\t\t\t\tdifX = relativeX - segment[segment.length - 4];\n\t\t\t\t\tdifY = relativeY - segment[segment.length - 3];\n\t\t\t\t\tsegment.push(relativeX + difX, relativeY + difY, x + ((relativeX + difX * 1.5) - x) * twoThirds, y + ((relativeY + difY * 1.5) - y) * twoThirds, (relativeX = x), (relativeY = y));\n\t\t\t\t\ti += 2;\n\n\t\t\t\t// \"H\" (horizontal line)\n\t\t\t\t} else if (command === \"H\") {\n\t\t\t\t\tline(relativeX, relativeY, (relativeX = x), relativeY);\n\t\t\t\t\ti += 1;\n\n\t\t\t\t// \"V\" (vertical line)\n\t\t\t\t} else if (command === \"V\") {\n\t\t\t\t\t//adjust values because the first (and only one) isn't x in this case, it's y.\n\t\t\t\t\tline(relativeX, relativeY, relativeX, (relativeY = x + (isRelative ? relativeY - relativeX : 0)));\n\t\t\t\t\ti += 1;\n\n\t\t\t\t// \"L\" (line) or \"Z\" (close)\n\t\t\t\t} else if (command === \"L\" || command === \"Z\") {\n\t\t\t\t\tif (command === \"Z\") {\n\t\t\t\t\t\tx = startX;\n\t\t\t\t\t\ty = startY;\n\t\t\t\t\t\tsegment.closed = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (command === \"L\" || Math.abs(relativeX - x) > 0.5 || Math.abs(relativeY - y) > 0.5) {\n\t\t\t\t\t\tline(relativeX, relativeY, x, y);\n\t\t\t\t\t\tif (command === \"L\") {\n\t\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trelativeX = x;\n\t\t\t\t\trelativeY = y;\n\n\t\t\t\t// \"A\" (arc)\n\t\t\t\t} else if (command === \"A\") {\n\t\t\t\t\tbeziers = _arcToBeziers(relativeX, relativeY, +a[i+1], +a[i+2], +a[i+3], +a[i+4], +a[i+5], (isRelative ? relativeX : 0) + a[i+6]*1, (isRelative ? relativeY : 0) + a[i+7]*1);\n\t\t\t\t\tif (beziers) {\n\t\t\t\t\t\tfor (j = 0; j < beziers.length; j++) {\n\t\t\t\t\t\t\tsegment.push(beziers[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trelativeX = segment[segment.length-2];\n\t\t\t\t\trelativeY = segment[segment.length-1];\n\t\t\t\t\ti += 7;\n\n\t\t\t\t} else {\n\t\t\t\t\t_log(errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = segment.length;\n\t\t\tif (i < 6) { //in case there's odd SVG like a M0,0 command at the very end.\n\t\t\t\tpath.pop();\n\t\t\t\ti = 0;\n\t\t\t} else if (segment[0] === segment[i-2] && segment[1] === segment[i-1]) {\n\t\t\t\tsegment.closed = true;\n\t\t\t}\n\t\t\tpath.totalPoints = points + i;\n\t\t\treturn path;\n\t\t},\n\n\t\t//adds a certain number of Beziers while maintaining the path shape (so that the start/end values can have a matching quantity of points to animate). Only pass in ONE segment of the Bezier at a time. Format: [xAnchor, yAnchor, xControlPoint1, yControlPoint1, xControlPoint2, yControlPoint2, xAnchor, yAnchor, xControlPoint1, etc...]\n\t\t_subdivideSegment = function(segment, quantity) {\n\t\t\tvar tally = 0,\n\t\t\t\tmax = 0.999999,\n\t\t\t\tl = segment.length,\n\t\t\t\tnewPointsPerSegment = quantity / ((l - 2) / 6),\n\t\t\t\tax, ay, cp1x, cp1y, cp2x, cp2y, bx, by,\n\t\t\t\tx1, y1, x2, y2, i, t;\n\t\t\tfor (i = 2; i < l; i += 6) {\n\t\t\t\ttally += newPointsPerSegment;\n\t\t\t\twhile (tally > max) { //compare with 0.99999 instead of 1 in order to prevent rounding errors\n\t\t\t\t\tax = segment[i-2];\n\t\t\t\t\tay = segment[i-1];\n\t\t\t\t\tcp1x = segment[i];\n\t\t\t\t\tcp1y = segment[i+1];\n\t\t\t\t\tcp2x = segment[i+2];\n\t\t\t\t\tcp2y = segment[i+3];\n\t\t\t\t\tbx = segment[i+4];\n\t\t\t\t\tby = segment[i+5];\n\t\t\t\t\tt = 1 / ((Math.floor(tally) || 1) + 1); //progress along the bezier (value between 0 and 1)\n\t\t\t\t\tx1 = ax + (cp1x - ax) * t;\n\t\t\t\t\tx2 = cp1x + (cp2x - cp1x) * t;\n\t\t\t\t\tx1 += (x2 - x1) * t;\n\t\t\t\t\tx2 += ((cp2x + (bx - cp2x) * t) - x2) * t;\n\n\t\t\t\t\ty1 = ay + (cp1y - ay) * t;\n\t\t\t\t\ty2 = cp1y + (cp2y - cp1y) * t;\n\t\t\t\t\ty1 += (y2 - y1) * t;\n\t\t\t\t\ty2 += ((cp2y + (by - cp2y) * t) - y2) * t;\n\n\t\t\t\t\tsegment.splice(i, 4,\n\t\t\t\t\t\tax + (cp1x - ax) * t,   //first control point\n\t\t\t\t\t\tay + (cp1y - ay) * t,\n\t\t\t\t\t\tx1,                     //second control point\n\t\t\t\t\t\ty1,\n\t\t\t\t\t\tx1 + (x2 - x1) * t,     //new fabricated anchor on line\n\t\t\t\t\t\ty1 + (y2 - y1) * t,\n\t\t\t\t\t\tx2,                     //third control point\n\t\t\t\t\t\ty2,\n\t\t\t\t\t\tcp2x + (bx - cp2x) * t, //fourth control point\n\t\t\t\t\t\tcp2y + (by - cp2y) * t\n\t\t\t\t\t);\n\t\t\t\t\ti += 6;\n\t\t\t\t\tl += 6;\n\t\t\t\t\ttally--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn segment;\n\t\t},\n\t\t_rawPathToString = function(rawPath, precision) {\n\t\t\tvar s = \"\",\n\t\t\t\tspace = \" \",\n\t\t\t\tl = rawPath.length,\n\t\t\t\trnd = Math.pow(10, precision || 2),\n\t\t\t\ti, j, segment;\n\t\t\tfor (j = 0; j < rawPath.length; j++) {\n\t\t\t\tsegment = rawPath[j];\n\t\t\t\tl = segment.length;\n\t\t\t\ts += \"M\" + (((segment[0] * rnd) | 0) / rnd) + space + (((segment[1] * rnd) | 0) / rnd) + \" C\";\n\t\t\t\tfor (i = 2; i < l; i++) { //this is actually faster than just doing a join() on the array, possibly because the numbers have so many decimal places\n\t\t\t\t\ts += (((segment[i] * rnd) | 0) / rnd) + space;\n\t\t\t\t}\n\t\t\t\tif (segment.closed) {\n\t\t\t\t\ts += \"z\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s;\n\t\t},\n\t\t_reverseBezier = function(segment) {\n\t\t\tvar a = [],\n\t\t\t\ti = segment.length - 1,\n\t\t\t\tl = 0;\n\t\t\twhile (--i > -1) {\n\t\t\t\ta[l++] = segment[i];\n\t\t\t\ta[l++] = segment[i+1];\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tsegment[i] = a[i];\n\t\t\t}\n\t\t\tsegment.reversed = !segment.reversed;\n\t\t},\n\t\t_getAverageXY = function(segment) {\n\t\t\tvar l = segment.length,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0,\n\t\t\t\ti;\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tx += segment[i++];\n\t\t\t\ty += segment[i];\n\t\t\t}\n\t\t\treturn [x / (l / 2), y / (l / 2)];\n\t\t},\n\t\t_getSize = function(segment) { //rough estimate of the bounding box (based solely on the anchors) of a single segment. sets \"size\", \"centerX\", and \"centerY\" properties on the bezier array itself, and returns the size (width * height)\n\t\t\tvar l = segment.length,\n\t\t\t\txMax = segment[0],\n\t\t\t\txMin = xMax,\n\t\t\t\tyMax = segment[1],\n\t\t\t\tyMin = yMax,\n\t\t\t\tx, y, i;\n\t\t\tfor (i = 6; i < l; i+=6) {\n\t\t\t\tx = segment[i];\n\t\t\t\ty = segment[i+1];\n\t\t\t\tif (x > xMax) {\n\t\t\t\t\txMax = x;\n\t\t\t\t} else if (x < xMin) {\n\t\t\t\t\txMin = x;\n\t\t\t\t}\n\t\t\t\tif (y > yMax) {\n\t\t\t\t\tyMax = y;\n\t\t\t\t} else if (y < yMin) {\n\t\t\t\t\tyMin = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsegment.centerX = (xMax + xMin) / 2;\n\t\t\tsegment.centerY = (yMax + yMin) / 2;\n\t\t\treturn (segment.size = (xMax - xMin) * (yMax - yMin));\n\t\t},\n\t\t_getTotalSize = function(rawPath, samplesPerBezier) { //rough estimate of the bounding box of the entire list of Bezier segments (based solely on the anchors). sets \"size\", \"centerX\", and \"centerY\" properties on the bezier array itself, and returns the size (width * height)\n\t\t\tsamplesPerBezier = samplesPerBezier || 3;\n\t\t\tvar j = rawPath.length,\n\t\t\t\txMax = rawPath[0][0],\n\t\t\t\txMin = xMax,\n\t\t\t\tyMax = rawPath[0][1],\n\t\t\t\tyMin = yMax,\n\t\t\t\tinc = 1 / samplesPerBezier,\n\t\t\t\tl, x, y, i, segment, k, t, inv, x1, y1, x2, x3, x4, y2, y3, y4;\n\t\t\twhile (--j > -1) {\n\t\t\t\tsegment = rawPath[j];\n\t\t\t\tl = segment.length;\n\t\t\t\tfor (i = 6; i < l; i+=6) {\n\t\t\t\t\tx1 = segment[i];\n\t\t\t\t\ty1 = segment[i+1];\n\t\t\t\t\tx2 = segment[i+2] - x1;\n\t\t\t\t\ty2 = segment[i+3] - y1;\n\t\t\t\t\tx3 = segment[i+4] - x1;\n\t\t\t\t\ty3 = segment[i+5] - y1;\n\t\t\t\t\tx4 = segment[i+6] - x1;\n\t\t\t\t\ty4 = segment[i+7] - y1;\n\t\t\t\t\tk = samplesPerBezier;\n\t\t\t\t\twhile (--k > -1) {\n\t\t\t\t\t\tt = inc * k;\n\t\t\t\t\t\tinv = 1 - t;\n\t\t\t\t\t\tx = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t + x1;\n\t\t\t\t\t\ty = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t + y1;\n\t\t\t\t\t\tif (x > xMax) {\n\t\t\t\t\t\t\txMax = x;\n\t\t\t\t\t\t} else if (x < xMin) {\n\t\t\t\t\t\t\txMin = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (y > yMax) {\n\t\t\t\t\t\t\tyMax = y;\n\t\t\t\t\t\t} else if (y < yMin) {\n\t\t\t\t\t\t\tyMin = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trawPath.centerX = (xMax + xMin) / 2;\n\t\t\trawPath.centerY = (yMax + yMin) / 2;\n\t\t\trawPath.left = xMin;\n\t\t\trawPath.width = (xMax - xMin);\n\t\t\trawPath.top = yMin;\n\t\t\trawPath.height = (yMax - yMin);\n\t\t\treturn (rawPath.size = (xMax - xMin) * (yMax - yMin));\n\t\t},\n\t\t_sortByComplexity = function(a, b) {\n\t\t\treturn b.length - a.length;\n\t\t},\n\t\t_sortBySize = function(a, b) {\n\t\t\tvar sizeA = a.size || _getSize(a),\n\t\t\t\tsizeB = b.size || _getSize(b);\n\t\t\treturn (Math.abs(sizeB - sizeA) < (sizeA + sizeB) / 20) ? (b.centerX - a.centerX) || (b.centerY - a.centerY) : sizeB - sizeA; //if the size is within 10% of each other, prioritize position from left to right, then top to bottom.\n\t\t},\n\t\t_offsetSegment = function(segment, shapeIndex) {\n\t\t\tvar a = segment.slice(0),\n\t\t\t\tl = segment.length,\n\t\t\t\twrap = l - 2,\n\t\t\t\ti, index;\n\t\t\tshapeIndex = shapeIndex | 0;\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tindex = (i + shapeIndex) % wrap;\n\t\t\t\tsegment[i++] = a[index];\n\t\t\t\tsegment[i] = a[index+1];\n\t\t\t}\n\t\t},\n\t\t_getTotalMovement = function(sb, eb, shapeIndex, offsetX, offsetY) {\n\t\t\tvar l = sb.length,\n\t\t\t\td = 0,\n\t\t\t\twrap = l - 2,\n\t\t\t\tindex, i, x, y;\n\t\t\tshapeIndex *= 6;\n\t\t\tfor (i = 0; i < l; i += 6) {\n\t\t\t\tindex = (i + shapeIndex) % wrap;\n\t\t\t\ty = sb[index] - (eb[i] - offsetX);\n\t\t\t\tx = sb[index+1] - (eb[i+1] - offsetY);\n\t\t\t\td += _sqrt(x * x + y * y);\n\t\t\t}\n\t\t\treturn d;\n\t\t},\n\t\t_getClosestShapeIndex = function(sb, eb, checkReverse) { //finds the index in a closed cubic bezier array that's closest to the angle provided (angle measured from the center or average x/y).\n\t\t\tvar l = sb.length,\n\t\t\t\tsCenter = _getAverageXY(sb), //when comparing distances, adjust the coordinates as if the shapes are centered with each other.\n\t\t\t\teCenter = _getAverageXY(eb),\n\t\t\t\toffsetX = eCenter[0] - sCenter[0],\n\t\t\t\toffsetY = eCenter[1] - sCenter[1],\n\t\t\t\tmin = _getTotalMovement(sb, eb, 0, offsetX, offsetY),\n\t\t\t\tminIndex = 0,\n\t\t\t\tcopy, d, i;\n\t\t\tfor (i = 6; i < l; i += 6) {\n\t\t\t\td = _getTotalMovement(sb, eb, i / 6, offsetX, offsetY);\n\t\t\t\tif (d < min) {\n\t\t\t\t\tmin = d;\n\t\t\t\t\tminIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (checkReverse) {\n\t\t\t\tcopy = sb.slice(0);\n\t\t\t\t_reverseBezier(copy);\n\t\t\t\tfor (i = 6; i < l; i += 6) {\n\t\t\t\t\td = _getTotalMovement(copy, eb, i / 6, offsetX, offsetY);\n\t\t\t\t\tif (d < min) {\n\t\t\t\t\t\tmin = d;\n\t\t\t\t\t\tminIndex = -i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn minIndex / 6;\n\t\t},\n\t\t_getClosestAnchor = function(rawPath, x, y) { //finds the x/y of the anchor that's closest to the provided x/y coordinate (returns an array, like [x, y]). The bezier should be the top-level type that contains an array for each segment.\n\t\t\tvar j = rawPath.length,\n\t\t\t\tclosestDistance = _bigNum,\n\t\t\t\tclosestX = 0,\n\t\t\t\tclosestY = 0,\n\t\t\t\tsegment, dx, dy, d, i, l;\n\t\t\twhile (--j > -1) {\n\t\t\t\tsegment = rawPath[j];\n\t\t\t\tl = segment.length;\n\t\t\t\tfor (i = 0; i < l; i += 6) {\n\t\t\t\t\tdx = segment[i] - x;\n\t\t\t\t\tdy = segment[i+1] - y;\n\t\t\t\t\td = _sqrt(dx * dx + dy * dy);\n\t\t\t\t\tif (d < closestDistance) {\n\t\t\t\t\t\tclosestDistance = d;\n\t\t\t\t\t\tclosestX = segment[i];\n\t\t\t\t\t\tclosestY = segment[i+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn [closestX, closestY];\n\t\t},\n\t\t_getClosestSegment = function(bezier, pool, startIndex, sortRatio, offsetX, offsetY) { //matches the bezier to the closest one in a pool (array) of beziers, assuming they are in order of size and we shouldn't drop more than 20% of the size, otherwise prioritizing location (total distance to the center). Extracts the segment out of the pool array and returns it.\n\t\t\tvar l = pool.length,\n\t\t\t\tindex = 0,\n\t\t\t\tminSize = Math.min(bezier.size || _getSize(bezier), pool[startIndex].size || _getSize(pool[startIndex])) * sortRatio, //limit things based on a percentage of the size of either the bezier or the next element in the array, whichever is smaller.\n\t\t\t\tmin = _bigNum,\n\t\t\t\tcx = bezier.centerX + offsetX,\n\t\t\t\tcy = bezier.centerY + offsetY,\n\t\t\t\tsize, i, dx, dy, d;\n\t\t\tfor (i = startIndex; i < l; i++) {\n\t\t\t\tsize = pool[i].size || _getSize(pool[i]);\n\t\t\t\tif (size < minSize) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdx = pool[i].centerX - cx;\n\t\t\t\tdy = pool[i].centerY - cy;\n\t\t\t\td = _sqrt(dx * dx + dy * dy);\n\t\t\t\tif (d < min) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tmin = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = pool[index];\n\t\t\tpool.splice(index, 1);\n\t\t\treturn d;\n\t\t},\n\t\t_equalizeSegmentQuantity = function(start, end, shapeIndex, map, fillSafe) { //returns an array of shape indexes, 1 for each segment.\n\t\t\tvar dif = end.length - start.length,\n\t\t\t\tlonger = dif > 0 ? end : start,\n\t\t\t\tshorter = dif > 0 ? start : end,\n\t\t\t\tadded = 0,\n\t\t\t\tsortMethod = (map === \"complexity\") ? _sortByComplexity : _sortBySize,\n\t\t\t\tsortRatio = (map === \"position\") ? 0 : (typeof(map) === \"number\") ? map : 0.8,\n\t\t\t\ti = shorter.length,\n\t\t\t\tshapeIndices = (typeof(shapeIndex) === \"object\" && shapeIndex.push) ? shapeIndex.slice(0) : [shapeIndex],\n\t\t\t\treverse = (shapeIndices[0] === \"reverse\" || shapeIndices[0] < 0),\n\t\t\t\tlog = (shapeIndex === \"log\"),\n\t\t\t\teb, sb, b, x, y, offsetX, offsetY;\n\t\t\tif (!shorter[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (longer.length > 1) {\n\t\t\t\tstart.sort(sortMethod);\n\t\t\t\tend.sort(sortMethod);\n\t\t\t\toffsetX = longer.size || _getTotalSize(longer); //ensures centerX and centerY are defined (used below).\n\t\t\t\toffsetX = shorter.size || _getTotalSize(shorter);\n\t\t\t\toffsetX = longer.centerX - shorter.centerX;\n\t\t\t\toffsetY = longer.centerY - shorter.centerY;\n\t\t\t\tif (sortMethod === _sortBySize) {\n\t\t\t\t\tfor (i = 0; i < shorter.length; i++) {\n\t\t\t\t\t\tlonger.splice(i, 0, _getClosestSegment(shorter[i], longer, i, sortRatio, offsetX, offsetY));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dif) {\n\t\t\t\tif (dif < 0) {\n\t\t\t\t\tdif = -dif;\n\t\t\t\t}\n\t\t\t\tif (longer[0].length > shorter[0].length) { //since we use shorter[0] as the one to map the origination point of any brand new fabricated segments, do any subdividing first so that there are more points to choose from (if necessary)\n\t\t\t\t\t_subdivideSegment(shorter[0], ((longer[0].length - shorter[0].length)/6) | 0);\n\t\t\t\t}\n\t\t\t\ti = shorter.length;\n\t\t\t\twhile (added < dif) {\n\t\t\t\t\tx = longer[i].size || _getSize(longer[i]); //just to ensure centerX and centerY are calculated which we use on the next line.\n\t\t\t\t\tb = _getClosestAnchor(shorter, longer[i].centerX, longer[i].centerY);\n\t\t\t\t\tx = b[0];\n\t\t\t\t\ty = b[1];\n\t\t\t\t\tshorter[i++] = [x, y, x, y, x, y, x, y];\n\t\t\t\t\tshorter.totalPoints += 8;\n\t\t\t\t\tadded++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < start.length; i++) {\n\t\t\t\teb = end[i];\n\t\t\t\tsb = start[i];\n\t\t\t\tdif = eb.length - sb.length;\n\t\t\t\tif (dif < 0) {\n\t\t\t\t\t_subdivideSegment(eb, (-dif/6) | 0);\n\t\t\t\t} else if (dif > 0) {\n\t\t\t\t\t_subdivideSegment(sb, (dif/6) | 0);\n\t\t\t\t}\n\t\t\t\tif (reverse && fillSafe !== false && !sb.reversed) {\n\t\t\t\t\t_reverseBezier(sb);\n\t\t\t\t}\n\t\t\t\tshapeIndex = (shapeIndices[i] || shapeIndices[i] === 0) ? shapeIndices[i] : \"auto\";\n\t\t\t\tif (shapeIndex) {\n\t\t\t\t\t//if start shape is closed, find the closest point to the start/end, and re-organize the bezier points accordingly so that the shape morphs in a more intuitive way.\n\t\t\t\t\tif (sb.closed || (Math.abs(sb[0] - sb[sb.length - 2]) < 0.5 && Math.abs(sb[1] - sb[sb.length - 1]) < 0.5)) {\n\t\t\t\t\t\tif (shapeIndex === \"auto\" || shapeIndex === \"log\") {\n\t\t\t\t\t\t\tshapeIndices[i] = shapeIndex = _getClosestShapeIndex(sb, eb, (!i || fillSafe === false));\n\t\t\t\t\t\t\tif (shapeIndex < 0) {\n\t\t\t\t\t\t\t\treverse = true;\n\t\t\t\t\t\t\t\t_reverseBezier(sb);\n\t\t\t\t\t\t\t\tshapeIndex = -shapeIndex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_offsetSegment(sb, shapeIndex * 6);\n\n\t\t\t\t\t\t} else if (shapeIndex !== \"reverse\") {\n\t\t\t\t\t\t\tif (i && shapeIndex < 0) { //only happens if an array is passed as shapeIndex and a negative value is defined for an index beyond 0. Very rare, but helpful sometimes.\n\t\t\t\t\t\t\t\t_reverseBezier(sb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_offsetSegment(sb, (shapeIndex < 0 ? -shapeIndex : shapeIndex) * 6);\n\t\t\t\t\t\t}\n\t\t\t\t\t//otherwise, if it's not a closed shape, consider reversing it if that would make the overall travel less\n\t\t\t\t\t} else if (!reverse && (shapeIndex === \"auto\" && (Math.abs(eb[0] - sb[0]) + Math.abs(eb[1] - sb[1]) + Math.abs(eb[eb.length - 2] - sb[sb.length - 2]) + Math.abs(eb[eb.length - 1] - sb[sb.length - 1]) > Math.abs(eb[0] - sb[sb.length - 2]) + Math.abs(eb[1] - sb[sb.length - 1]) + Math.abs(eb[eb.length - 2] - sb[0]) + Math.abs(eb[eb.length - 1] - sb[1])) || (shapeIndex % 2))) {\n\t\t\t\t\t\t_reverseBezier(sb);\n\t\t\t\t\t\tshapeIndices[i] = -1;\n\t\t\t\t\t\treverse = true;\n\t\t\t\t\t} else if (shapeIndex === \"auto\") {\n\t\t\t\t\t\tshapeIndices[i] = 0;\n\t\t\t\t\t} else if (shapeIndex === \"reverse\") {\n\t\t\t\t\t\tshapeIndices[i] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (sb.closed !== eb.closed) { //if one is closed and one isn't, don't close either one otherwise the tweening will look weird (but remember, the beginning and final states will honor the actual values, so this only affects the inbetween state)\n\t\t\t\t\t\tsb.closed = eb.closed = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (log) {\n\t\t\t\t_log(\"shapeIndex:[\" + shapeIndices.join(\",\") + \"]\");\n\t\t\t}\n\t\t\tstart.shapeIndex = shapeIndices;\n\t\t\treturn shapeIndices;\n\t\t},\n\t\t_pathFilter = function(a, shapeIndex, map, precompile, fillSafe) {\n\t\t\tvar start = _stringToRawPath(a[0]),\n\t\t\t\tend = _stringToRawPath(a[1]);\n\t\t\tif (!_equalizeSegmentQuantity(start, end, (shapeIndex || shapeIndex === 0) ? shapeIndex : \"auto\", map, fillSafe)) {\n\t\t\t\treturn; //malformed path data or null target\n\t\t\t}\n\t\t\ta[0] = _rawPathToString(start);\n\t\t\ta[1] = _rawPathToString(end);\n\t\t\tif (precompile === \"log\" || precompile === true) {\n\t\t\t\t_log('precompile:[\"' + a[0] + '\",\"' + a[1] + '\"]');\n\t\t\t}\n\t\t},\n\t\t/*\n\t\t_buildPathFilter = function(shapeIndex, map, precompile) {\n\t\t\treturn (map || precompile || shapeIndex || shapeIndex === 0) ? function(a) {\n\t\t\t\t_pathFilter(a, shapeIndex, map, precompile);\n\t\t\t} : _pathFilter;\n\t\t},\n\t\t*/\n\t\t_offsetPoints = function(text, offset) {\n\t\t\tif (!offset) {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t\tvar a = text.match(_numbersExp) || [],\n\t\t\t\tl = a.length,\n\t\t\t\ts = \"\",\n\t\t\t\tinc, i, j;\n\t\t\tif (offset === \"reverse\") {\n\t\t\t\ti = l-1;\n\t\t\t\tinc = -2;\n\t\t\t} else {\n\t\t\t\ti = (((parseInt(offset, 10) || 0) * 2 + 1) + l * 100) % l;\n\t\t\t\tinc = 2;\n\t\t\t}\n\t\t\tfor (j = 0; j < l; j += 2) {\n\t\t\t\ts += a[i-1] + \",\" + a[i] + \" \";\n\t\t\t\ti = (i + inc) % l;\n\t\t\t}\n\t\t\treturn s;\n\t\t},\n\t\t//adds a certain number of points while maintaining the polygon/polyline shape (so that the start/end values can have a matching quantity of points to animate). Returns the revised string.\n\t\t_equalizePointQuantity = function(a, quantity) {\n\t\t\tvar tally = 0,\n\t\t\t\tx = parseFloat(a[0]),\n\t\t\t\ty = parseFloat(a[1]),\n\t\t\t\ts = x + \",\" + y + \" \",\n\t\t\t\tmax = 0.999999,\n\t\t\t\tnewPointsPerSegment, i, l, j, factor, nextX, nextY;\n\t\t\tl = a.length;\n\t\t\tnewPointsPerSegment = quantity * 0.5 / (l * 0.5 - 1);\n\t\t\tfor (i = 0; i < l-2; i += 2) {\n\t\t\t\ttally += newPointsPerSegment;\n\t\t\t\tnextX = parseFloat(a[i+2]);\n\t\t\t\tnextY = parseFloat(a[i+3]);\n\t\t\t\tif (tally > max) { //compare with 0.99999 instead of 1 in order to prevent rounding errors\n\t\t\t\t\tfactor = 1 / (Math.floor(tally) + 1);\n\t\t\t\t\tj = 1;\n\t\t\t\t\twhile (tally > max) {\n\t\t\t\t\t\ts += (x + (nextX - x) * factor * j).toFixed(2) + \",\" + (y + (nextY - y) * factor * j).toFixed(2) + \" \";\n\t\t\t\t\t\ttally--;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts += nextX + \",\" + nextY + \" \";\n\t\t\t\tx = nextX;\n\t\t\t\ty = nextY;\n\t\t\t}\n\t\t\treturn s;\n\t\t},\n\t\t_pointsFilter = function(a) {\n\t\t\tvar startNums = a[0].match(_numbersExp) || [],\n\t\t\t\tendNums = a[1].match(_numbersExp) || [],\n\t\t\t\tdif = endNums.length - startNums.length;\n\t\t\tif (dif > 0) {\n\t\t\t\ta[0] = _equalizePointQuantity(startNums, dif);\n\t\t\t} else {\n\t\t\t\ta[1] = _equalizePointQuantity(endNums, -dif);\n\t\t\t}\n\t\t},\n\t\t_buildPointsFilter = function(shapeIndex) {\n\t\t\treturn !isNaN(shapeIndex) ? function(a) {\n\t\t\t\t_pointsFilter(a);\n\t\t\t\ta[1] = _offsetPoints(a[1], parseInt(shapeIndex, 10));\n\t\t\t} : _pointsFilter;\n\t\t},\n\t\t_createPath = function(e, ignore) {\n\t\t\tvar path = _gsScope.document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\"),\n\t\t\t\tattr = Array.prototype.slice.call(e.attributes),\n\t\t\t\ti = attr.length,\n\t\t\t\tname;\n\t\t\tignore = \",\" + ignore + \",\";\n\t\t\twhile (--i > -1) {\n\t\t\t\tname = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.\n\t\t\t\tif (ignore.indexOf(\",\" + name + \",\") === -1) {\n\t\t\t\t\tpath.setAttributeNS(null, name, attr[i].nodeValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn path;\n\t\t},\n\t\t_typeAttrs = {\n\t\t\trect:\"rx,ry,x,y,width,height\",\n\t\t\tcircle:\"r,cx,cy\",\n\t\t\tellipse:\"rx,ry,cx,cy\",\n\t\t\tline:\"x1,x2,y1,y2\"\n\t\t},\n\t\t_attrToObj = function(e, attrs) {\n\t\t\tvar props = attrs ? attrs.split(\",\") : [],\n\t\t\t\tobj = {},\n\t\t\t\ti = props.length;\n\t\t\twhile (--i > -1) {\n\t\t\t\tobj[props[i]] = +e.getAttribute(props[i]) || 0;\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\t\t_convertToPath = function(e, swap) {\n\t\t\tvar type = e.tagName.toLowerCase(),\n\t\t\t\tcirc = 0.552284749831,\n\t\t\t\tdata, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr;\n\t\t\tif (type === \"path\" || !e.getBBox) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tpath = _createPath(e, \"x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points\");\n\t\t\tattr = _attrToObj(e, _typeAttrs[type]);\n\t\t\tif (type === \"rect\") {\n\t\t\t\tr = attr.rx;\n\t\t\t\try = attr.ry;\n\t\t\t\tx = attr.x;\n\t\t\t\ty = attr.y;\n\t\t\t\tw = attr.width - r * 2;\n\t\t\t\th = attr.height - ry * 2;\n\t\t\t\tif (r || ry) { //if there are rounded corners, render cubic beziers\n\t\t\t\t\tx2 = x + r * (1 - circ);\n\t\t\t\t\tx3 = x + r;\n\t\t\t\t\tx4 = x3 + w;\n\t\t\t\t\tx5 = x4 + r * circ;\n\t\t\t\t\tx6 = x4 + r;\n\t\t\t\t\ty2 = y + ry * (1 - circ);\n\t\t\t\t\ty3 = y + ry;\n\t\t\t\t\ty4 = y3 + h;\n\t\t\t\t\ty5 = y4 + ry * circ;\n\t\t\t\t\ty6 = y4 + ry;\n\t\t\t\t\tdata = \"M\" + x6 + \",\" + y3 + \" V\" + y4 + \" C\" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(\",\") + \"z\";\n\t\t\t\t} else {\n\t\t\t\t\tdata = \"M\" + (x + w) + \",\" + y + \" v\" + h + \" h\" + (-w) + \" v\" + (-h) + \" h\" + w + \"z\";\n\t\t\t\t}\n\n\t\t\t} else if (type === \"circle\" || type === \"ellipse\") {\n\t\t\t\tif (type === \"circle\") {\n\t\t\t\t\tr = ry = attr.r;\n\t\t\t\t\trycirc = r * circ;\n\t\t\t\t} else {\n\t\t\t\t\tr = attr.rx;\n\t\t\t\t\try = attr.ry;\n\t\t\t\t\trycirc = ry * circ;\n\t\t\t\t}\n\t\t\t\tx = attr.cx;\n\t\t\t\ty = attr.cy;\n\t\t\t\trcirc = r * circ;\n\t\t\t\tdata = \"M\" + (x+r) + \",\" + y + \" C\" + [x+r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(\",\") + \"z\";\n\t\t\t} else if (type === \"line\") {\n\t\t\t\tdata = \"M\" + attr.x1 + \",\" + attr.y1 + \" L\" + attr.x2 + \",\" + attr.y2; //previously, we just converted to \"Mx,y Lx,y\" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.\n\t\t\t} else if (type === \"polyline\" || type === \"polygon\") {\n\t\t\t\tpoints = (e.getAttribute(\"points\") + \"\").match(_numbersExp) || [];\n\t\t\t\tx = points.shift();\n\t\t\t\ty = points.shift();\n\t\t\t\tdata = \"M\" + x + \",\" + y + \" L\" + points.join(\",\");\n\t\t\t\tif (type === \"polygon\") {\n\t\t\t\t\tdata += \",\" + x + \",\" + y + \"z\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tpath.setAttribute(\"d\", _rawPathToString(path._gsRawPath = _stringToRawPath(data)));\n\t\t\tif (swap && e.parentNode) {\n\t\t\t\te.parentNode.insertBefore(path, e);\n\t\t\t\te.parentNode.removeChild(e);\n\t\t\t}\n\n\t\t\treturn path;\n\t\t},\n\t\t_parseShape = function(shape, forcePath, target) {\n\t\t\tvar isString = typeof(shape) === \"string\",\n\t\t\t\te, type;\n\t\t\tif (!isString || _selectorExp.test(shape) || (shape.match(_numbersExp) || []).length < 3) {\n\t\t\t\te = isString ? TweenLite.selector(shape) : (shape && shape[0]) ? shape : [shape]; //allow array-like objects like jQuery objects.\n\t\t\t\tif (e && e[0]) {\n\t\t\t\t\te = e[0];\n\t\t\t\t\ttype = (e.nodeName + \"\").toUpperCase();\n\t\t\t\t\tif (forcePath && type !== \"PATH\") { //if we were passed an element (or selector text for an element) that isn't a path, convert it.\n\t\t\t\t\t\te = _convertToPath(e, false);\n\t\t\t\t\t\ttype = \"PATH\";\n\t\t\t\t\t}\n\t\t\t\t\tshape = e.getAttribute(type === \"PATH\" ? \"d\" : \"points\") || \"\";\n\t\t\t\t\tif (e === target) { //if the shape matches the target element, the user wants to revert to the original which should have been stored in the data-original attribute\n\t\t\t\t\t\tshape = e.getAttributeNS(null, \"data-original\") || shape;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t_log(\"WARNING: invalid morph to: \" + shape);\n\t\t\t\t\tshape = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn shape;\n\t\t},\n\t\t//adds an \"isSmooth\" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.\n\t\t_populateSmoothData = function(rawPath, tolerance) {\n\t\t\tvar j = rawPath.length,\n\t\t\t\tlimit = 0.2 * (tolerance || 1),\n\t\t\t\tsmooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;\n\t\t\twhile (--j > -1) {\n\t\t\t\tsegment = rawPath[j];\n\t\t\t\tisSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];\n\t\t\t\tsmoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];\n\t\t\t\tisSmooth.length = 4;\n\t\t\t\tl = segment.length - 2;\n\t\t\t\tfor (i = 6; i < l; i += 6) {\n\t\t\t\t\tx = segment[i] - segment[i - 2];\n\t\t\t\t\ty = segment[i + 1] - segment[i - 1];\n\t\t\t\t\tx2 = segment[i + 2] - segment[i];\n\t\t\t\t\ty2 = segment[i + 3] - segment[i + 1];\n\t\t\t\t\ta = _atan2(y, x);\n\t\t\t\t\ta2 = _atan2(y2, x2);\n\t\t\t\t\tsmooth = (Math.abs(a - a2) < limit);\n\t\t\t\t\tif (smooth) {\n\t\t\t\t\t\tsmoothData[i - 2] = a;\n\t\t\t\t\t\tsmoothData[i + 2] = a2;\n\t\t\t\t\t\tsmoothData[i - 1] = _sqrt(x * x + y * y);\n\t\t\t\t\t\tsmoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t\t\t}\n\t\t\t\t\tisSmooth.push(smooth, smooth, 0, 0, smooth, smooth);\n\t\t\t\t}\n\t\t\t\t//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.\n\t\t\t\tif (segment[l] === segment[0] && segment[l+1] === segment[1]) {\n\t\t\t\t\tx = segment[0] - segment[l-2];\n\t\t\t\t\ty = segment[1] - segment[l-1];\n\t\t\t\t\tx2 = segment[2] - segment[0];\n\t\t\t\t\ty2 = segment[3] - segment[1];\n\t\t\t\t\ta = _atan2(y, x);\n\t\t\t\t\ta2 = _atan2(y2, x2);\n\t\t\t\t\tif (Math.abs(a - a2) < limit) {\n\t\t\t\t\t\tsmoothData[l-2] = a;\n\t\t\t\t\t\tsmoothData[2] = a2;\n\t\t\t\t\t\tsmoothData[l-1] = _sqrt(x * x + y * y);\n\t\t\t\t\t\tsmoothData[3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t\t\t\tisSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rawPath;\n\t\t},\n\t\t_parseOriginFactors = function(v) {\n\t\t\tvar a = v.trim().split(\" \"),\n\t\t\t\tx = (v.indexOf(\"left\") >= 0) ? 0 : (v.indexOf(\"right\") >= 0) ? 100 : isNaN(parseFloat(a[0])) ? 50 : parseFloat(a[0]),\n\t\t\t\ty = (v.indexOf(\"top\") >= 0) ? 0 : (v.indexOf(\"bottom\") >= 0) ? 100 : isNaN(parseFloat(a[1])) ? 50 : parseFloat(a[1]);\n\t\t\treturn {x:x / 100, y:y / 100};\n\t\t},\n\t\t_shortAngle = function(dif) {\n\t\t\treturn (dif !== dif % _PI) ? dif + ((dif < 0) ? _2PI : -_2PI) : dif;\n\t\t},\n\t\t_morphMessage = \"Use MorphSVGPlugin.convertToPath(elementOrSelectorText) to convert to a path before morphing.\",\n\n\n\n\t\tMorphSVGPlugin = _gsScope._gsDefine.plugin({\n\t\t\tpropName: \"morphSVG\",\n\t\t\tAPI: 2,\n\t\t\tglobal: true,\n\t\t\tversion: \"0.9.2\",\n\n\t\t\t//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.\n\t\t\tinit: function(target, value, tween, index) {\n\t\t\t\tvar cs = target.nodeType ? window.getComputedStyle(target) : {},\n\t\t\t\t\tfill = cs.fill + \"\",\n\t\t\t\t\tfillSafe = !(fill === \"none\" || (fill.match(_numbersExp) || [])[3] === \"0\" || cs.fillRule === \"evenodd\"),\n\t\t\t\t\torigins = (value.origin || \"50 50\").split(\",\"),\n\t\t\t\t\ttype, p, pt, shape, isPoly, shapeIndex, map, startSmooth, endSmooth, start, end, i, j, l, startSeg, endSeg, precompiled, sData, eData, originFactors, useRotation, offset;\n\t\t\t\tif (typeof(value) === \"function\") {\n\t\t\t\t\tvalue = value(index, target);\n\t\t\t\t}\n\t\t\t\ttype = (target.nodeName + \"\").toUpperCase();\n\t\t\t\tisPoly = (type === \"POLYLINE\" || type === \"POLYGON\");\n\t\t\t\tif (type !== \"PATH\" && !isPoly && !value.prop) {\n\t\t\t\t\t_log(\"WARNING: cannot morph a <\" + type + \"> element. \" + _morphMessage);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tp = (type === \"PATH\") ? \"d\" : \"points\";\n\t\t\t\tif (typeof(value) === \"string\" || value.getBBox || value[0]) {\n\t\t\t\t\tvalue = {shape:value};\n\t\t\t\t}\n\t\t\t\tif (!value.prop && typeof(target.setAttribute) !== \"function\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tshape = _parseShape(value.shape || value.d || value.points || \"\", (p === \"d\"), target);\n\t\t\t\tif (isPoly && _commands.test(shape)) {\n\t\t\t\t\t_log(\"WARNING: a <\" + type + \"> cannot accept path data. \" + _morphMessage);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tshapeIndex = (value.shapeIndex || value.shapeIndex === 0) ? value.shapeIndex : \"auto\";\n\t\t\t\tmap = value.map || MorphSVGPlugin.defaultMap;\n\t\t\t\tthis._prop = value.prop;\n\t\t\t\tthis._render = value.render || MorphSVGPlugin.defaultRender;\n\t\t\t\tthis._apply = (\"updateTarget\" in value) ? value.updateTarget : MorphSVGPlugin.defaultUpdateTarget;\n\t\t\t\tthis._rnd = Math.pow(10, isNaN(value.precision) ? 2 : +value.precision);\n\t\t\t\tthis._tween = tween;\n\t\t\t\tif (shape) {\n\t\t\t\t\tthis._target = target;\n\t\t\t\t\tprecompiled = (typeof(value.precompile) === \"object\");\n\t\t\t\t\tstart = this._prop ? target[this._prop] : target.getAttribute(p);\n\t\t\t\t\tif (!this._prop && !target.getAttributeNS(null, \"data-original\")) {\n\t\t\t\t\t\ttarget.setAttributeNS(null, \"data-original\", start); //record the original state in a data-original attribute so that we can revert to it later.\n\t\t\t\t\t}\n\t\t\t\t\tif (p === \"d\" || this._prop) {\n\t\t\t\t\t\tstart = _stringToRawPath(precompiled ? value.precompile[0] : start);\n\t\t\t\t\t\tend = _stringToRawPath(precompiled ? value.precompile[1] : shape);\n\t\t\t\t\t\tif (!precompiled && !_equalizeSegmentQuantity(start, end, shapeIndex, map, fillSafe)) {\n\t\t\t\t\t\t\treturn false; //malformed path data or null target\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.precompile === \"log\" || value.precompile === true) {\n\t\t\t\t\t\t\t_log('precompile:[\"' + _rawPathToString(start) + '\",\"' + _rawPathToString(end) + '\"]');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuseRotation = (value.type || MorphSVGPlugin.defaultType) !== \"linear\";\n\n\t\t\t\t\t\tif (useRotation) {\n\t\t\t\t\t\t\tstart = _populateSmoothData(start, value.smoothTolerance);\n\t\t\t\t\t\t\tend = _populateSmoothData(end, value.smoothTolerance   );\n\t\t\t\t\t\t\tif (!start.size) {\n\t\t\t\t\t\t\t\t_getTotalSize(start); //adds top/left/width/height values\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!end.size) {\n\t\t\t\t\t\t\t\t_getTotalSize(end);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginFactors = _parseOriginFactors(origins[0]);\n\t\t\t\t\t\t\tthis._origin = start.origin = {x:start.left + originFactors.x * start.width, y:start.top + originFactors.y * start.height};\n\t\t\t\t\t\t\tif (origins[1]) {\n\t\t\t\t\t\t\t\toriginFactors = _parseOriginFactors(origins[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._eOrigin = {x:end.left + originFactors.x * end.width, y:end.top + originFactors.y * end.height};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._rawPath = target._gsRawPath =  start;\n\n\t\t\t\t\t\tj = start.length;\n\t\t\t\t\t\twhile (--j > -1) {\n\t\t\t\t\t\t\tstartSeg = start[j];\n\t\t\t\t\t\t\tendSeg = end[j];\n\t\t\t\t\t\t\tstartSmooth = startSeg.isSmooth || [];\n\t\t\t\t\t\t\tendSmooth = endSeg.isSmooth || [];\n\t\t\t\t\t\t\tl = startSeg.length;\n\t\t\t\t\t\t\t_lastLinkedAnchor = 0; //reset; we use _lastLinkedAnchor in the _tweenRotation() method to help make sure that close points don't get ripped apart and rotate opposite directions. Typically we want to go the shortest direction, but if the previous anchor is going a different direction, we override this logic (within certain thresholds)\n\t\t\t\t\t\t\tfor (i = 0; i < l; i+=2) {\n\t\t\t\t\t\t\t\tif (endSeg[i] !== startSeg[i] || endSeg[i+1] !== startSeg[i+1]) {\n\t\t\t\t\t\t\t\t\tif (useRotation) {\n\t\t\t\t\t\t\t\t\t\tif (startSmooth[i] && endSmooth[i]) { //if BOTH starting and ending values are smooth (meaning control points have basically the same slope), interpolate the rotation and length instead of the coordinates (this is what makes things smooth).\n\t\t\t\t\t\t\t\t\t\t\tsData = startSeg.smoothData;\n\t\t\t\t\t\t\t\t\t\t\teData = endSeg.smoothData;\n\t\t\t\t\t\t\t\t\t\t\toffset = i + ((i === l - 4) ? 7 - l : 5); //helps us accommodate wrapping (like if the end and start anchors are identical and the control points are smooth).\n\t\t\t\t\t\t\t\t\t\t\tthis._controlPT = {_next:this._controlPT, i:i, j:j, l1s:sData[i+1], l1c:eData[i+1] - sData[i+1], l2s:sData[offset], l2c:eData[offset] - sData[offset]};\n\t\t\t\t\t\t\t\t\t\t\tpt = this._tweenRotation(startSeg, endSeg, i+2);\n\t\t\t\t\t\t\t\t\t\t\tthis._tweenRotation(startSeg, endSeg, i, pt);\n\t\t\t\t\t\t\t\t\t\t\tthis._tweenRotation(startSeg, endSeg, offset-1, pt);\n\t\t\t\t\t\t\t\t\t\t\ti+=4;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tthis._tweenRotation(startSeg, endSeg, i);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpt = this._addTween(startSeg, i, startSeg[i], endSeg[i]);\n\t\t\t\t\t\t\t\t\t\tpt = this._addTween(startSeg, i+1, startSeg[i+1], endSeg[i+1]) || pt;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpt = this._addTween(target, \"setAttribute\", target.getAttribute(p) + \"\", shape + \"\", \"morphSVG\", false, p, _buildPointsFilter(shapeIndex));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useRotation) {\n\t\t\t\t\t\tthis._addTween(this._origin, \"x\", this._origin.x, this._eOrigin.x);\n\t\t\t\t\t\tpt = this._addTween(this._origin, \"y\", this._origin.y, this._eOrigin.y);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pt) {\n\t\t\t\t\t\tthis._overwriteProps.push(\"morphSVG\");\n\t\t\t\t\t\tpt.end = shape;\n\t\t\t\t\t\tpt.endProp = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\tset: function(ratio) {\n\t\t\t\tvar rawPath = this._rawPath,\n\t\t\t\t\tcontrolPT = this._controlPT,\n\t\t\t\t\tanchorPT = this._anchorPT,\n\t\t\t\t\trnd = this._rnd,\n\t\t\t\t\ttarget = this._target,\n\t\t\t\t\ts, space, easeInOut, pt, segment, l, angle, i, j, x, y, sin, cos, offset;\n\t\t\t\tthis._super.setRatio.call(this, ratio);\n\t\t\t\tif (ratio === 1 && this._apply) {\n\t\t\t\t\tpt = this._firstPT;\n\t\t\t\t\twhile (pt) {\n\t\t\t\t\t\tif (pt.end) {\n\t\t\t\t\t\t\tif (this._prop) {\n\t\t\t\t\t\t\t\ttarget[this._prop] = pt.end;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.setAttribute(pt.endProp, pt.end); //make sure the end value is exactly as specified (in case we had to add fabricated points during the tween)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpt = pt._next;\n\t\t\t\t\t}\n\t\t\t\t} else if (rawPath) {\n\n\t\t\t\t\t//rotationally position the anchors\n\t\t\t\t\twhile (anchorPT) {\n\t\t\t\t\t\tangle = anchorPT.sa + ratio * anchorPT.ca;\n\t\t\t\t\t\tl = anchorPT.sl + ratio * anchorPT.cl;    //length\n\t\t\t\t\t\tanchorPT.t[anchorPT.i] = this._origin.x + _cos(angle) * l;\n\t\t\t\t\t\tanchorPT.t[anchorPT.i + 1] = this._origin.y + _sin(angle) * l;\n\t\t\t\t\t\tanchorPT = anchorPT._next;\n\t\t\t\t\t}\n\n\t\t\t\t\t//smooth out the control points\n\t\t\t\t\teaseInOut = ratio < 0.5 ? 2 * ratio * ratio : (4 - 2 * ratio) * ratio - 1;\n\t\t\t\t\twhile (controlPT) {\n\t\t\t\t\t\ti = controlPT.i;\n\t\t\t\t\t\tsegment = rawPath[controlPT.j];\n\t\t\t\t\t\toffset = i + ((i === segment.length - 4) ? 7 - segment.length : 5); //accommodates wrapping around of smooth points, like if the start and end anchors are on top of each other and their handles are smooth.\n\t\t\t\t\t\tangle = _atan2(segment[offset] - segment[i+1], segment[offset-1] - segment[i]); //average the angles\n\t\t\t\t\t\tsin = _sin(angle);\n\t\t\t\t\t\tcos = _cos(angle);\n\t\t\t\t\t\tx = segment[i+2];\n\t\t\t\t\t\ty = segment[i+3];\n\t\t\t\t\t\tl = controlPT.l1s + easeInOut * controlPT.l1c;    //length\n\t\t\t\t\t\tsegment[i] = x - cos * l;\n\t\t\t\t\t\tsegment[i+1] = y - sin * l;\n\t\t\t\t\t\tl = controlPT.l2s + easeInOut * controlPT.l2c;\n\t\t\t\t\t\tsegment[offset-1] = x + cos * l;\n\t\t\t\t\t\tsegment[offset] = y + sin * l;\n\t\t\t\t\t\tcontrolPT = controlPT._next;\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget._gsRawPath = rawPath;\n\n\t\t\t\t\tif (this._apply) {\n\t\t\t\t\t\ts = \"\";\n\t\t\t\t\t\tspace = \" \";\n\t\t\t\t\t\tfor (j = 0; j < rawPath.length; j++) {\n\t\t\t\t\t\t\tsegment = rawPath[j];\n\t\t\t\t\t\t\tl = segment.length;\n\t\t\t\t\t\t\ts += \"M\" + (((segment[0] * rnd) | 0) / rnd) + space + (((segment[1] * rnd) | 0) / rnd) + \" C\";\n\t\t\t\t\t\t\tfor (i = 2; i < l; i++) { //this is actually faster than just doing a join() on the array, possibly because the numbers have so many decimal places\n\t\t\t\t\t\t\t\ts += (((segment[i] * rnd) | 0) / rnd) + space;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this._prop) {\n\t\t\t\t\t\t\ttarget[this._prop] = s;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.setAttribute(\"d\", s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this._render && rawPath) {\n\t\t\t\t\tthis._render.call(this._tween, rawPath, target);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\tMorphSVGPlugin.prototype._tweenRotation = function(start, end, i, linkedPT) {\n\t\tvar so = this._origin,              //starting origin\n\t\t\teo = this._eOrigin,             //ending origin\n\t\t\tdx = start[i] - so.x,\n\t\t\tdy = start[i+1] - so.y,\n\t\t\td = _sqrt(dx * dx + dy * dy),   //length from starting origin to starting point\n\t\t\tsa = _atan2(dy, dx),\n\t\t\tangleDif, short;\n\t\tdx = end[i] - eo.x;\n\t\tdy = end[i+1] - eo.y;\n\t\tangleDif = _atan2(dy, dx) - sa;\n\t\tshort = _shortAngle(angleDif);\n\t\t//in the case of control points, we ALWAYS link them to their anchor so that they don't get torn apart and rotate the opposite direction. If it's not a control point, we look at the most recently linked point as long as they're within a certain rotational range of each other.\n\t\tif (!linkedPT && _lastLinkedAnchor && Math.abs(short + _lastLinkedAnchor.ca) < _angleMin) {\n\t\t\tlinkedPT = _lastLinkedAnchor;\n\t\t}\n\t\treturn (this._anchorPT = _lastLinkedAnchor = {\n\t\t\t_next:this._anchorPT,\n\t\t\tt:start,\n\t\t\tsa:sa,                              //starting angle\n\t\t\tca:(linkedPT && short * linkedPT.ca < 0 && Math.abs(short) > _angleMax) ? angleDif : short,  //change in angle\n\t\t\tsl:d,                               //starting length\n\t\t\tcl:_sqrt(dx * dx + dy * dy) - d,    //change in length\n\t\t\ti:i\n\t\t});\n\t};\n\n\tMorphSVGPlugin.pathFilter = _pathFilter;\n\tMorphSVGPlugin.pointsFilter = _pointsFilter;\n\tMorphSVGPlugin.getTotalSize = _getTotalSize;\n\tMorphSVGPlugin.subdivideRawBezier = MorphSVGPlugin.subdivideSegment = _subdivideSegment;\n\tMorphSVGPlugin.rawPathToString = _rawPathToString;\n\tMorphSVGPlugin.defaultType = \"linear\";\n\tMorphSVGPlugin.defaultUpdateTarget = true;\n\tMorphSVGPlugin.defaultMap = \"size\";\n\tMorphSVGPlugin.stringToRawPath = MorphSVGPlugin.pathDataToRawBezier = function(data) {\n\t\treturn _stringToRawPath(_parseShape(data, true));\n\t};\n\tMorphSVGPlugin.equalizeSegmentQuantity = _equalizeSegmentQuantity;\n\n\tMorphSVGPlugin.convertToPath = function(targets, swap) {\n\t\tif (typeof(targets) === \"string\") {\n\t\t\ttargets = TweenLite.selector(targets);\n\t\t}\n\t\tvar a = (!targets || targets.length === 0) ? [] : (targets.length && targets[0] && targets[0].nodeType) ? Array.prototype.slice.call(targets, 0) : [targets],\n\t\t\ti = a.length;\n\t\twhile (--i > -1) {\n\t\t\ta[i] = _convertToPath(a[i], (swap !== false));\n\t\t}\n\t\treturn a;\n\t};\n\n\tMorphSVGPlugin.pathDataToBezier = function(data, vars) { //converts SVG path data into an array of {x, y} objects that can be plugged directly into a bezier tween. You can optionally pass in a 2D matrix like [a, b, c, d, tx, ty] containing numbers that should transform each point.\n\t\tvar bezier = _stringToRawPath(_parseShape(data, true))[0] || [],\n\t\t\tprefix = 0,\n\t\t\ta, i, l, matrix, offsetX, offsetY, bbox, e;\n\t\tvars = vars || {};\n\t\te = vars.align || vars.relative;\n\t\tmatrix = vars.matrix || [1,0,0,1,0,0];\n\t\toffsetX = vars.offsetX || 0;\n\t\toffsetY = vars.offsetY || 0;\n\t\tif (e === \"relative\" || e === true) {\n\t\t\toffsetX -= bezier[0] * matrix[0] + bezier[1] * matrix[2];\n\t\t\toffsetY -= bezier[0] * matrix[1] + bezier[1] * matrix[3];\n\t\t\tprefix = \"+=\";\n\t\t} else {\n\t\t\toffsetX += matrix[4];\n\t\t\toffsetY += matrix[5];\n\t\t\tif (e) {\n\t\t\t\te = (typeof(e) === \"string\") ? TweenLite.selector(e) : (e && e[0]) ? e : [e]; //allow array-like objects like jQuery objects.\n\t\t\t\tif (e && e[0]) {\n\t\t\t\t\tbbox = e[0].getBBox() || {x:0, y:0};\n\t\t\t\t\toffsetX -= bbox.x;\n\t\t\t\t\toffsetY -= bbox.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta = [];\n\t\tl = bezier.length;\n\t\tif (matrix && matrix.join(\",\") !== \"1,0,0,1,0,0\") {\n\t\t\tfor (i = 0; i < l; i+=2) {\n\t\t\t\ta.push({x:prefix + (bezier[i] * matrix[0] + bezier[i+1] * matrix[2] + offsetX), y:prefix + (bezier[i] * matrix[1] + bezier[i+1] * matrix[3] + offsetY)});\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < l; i+=2) {\n\t\t\t\ta.push({x:prefix + (bezier[i] + offsetX), y:prefix + (bezier[i+1] + offsetY)});\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t};\n\n\n\nexport { MorphSVGPlugin, MorphSVGPlugin as default };"],"sourceRoot":""}