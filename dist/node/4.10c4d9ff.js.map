{"version":3,"sources":["webpack:///./shared/components/hero/assets/utils/DrawSVGPlugin.js","webpack:///./shared/components/hero/VideoControls.js","webpack:///./shared/components/hero/Video.js","webpack:///./shared/components/hero/assets/utils/MorphSVGPlugin.js"],"names":["DrawSVGPlugin","_doc","_gsScope","document","_computedStyleScope","window","defaultView","getComputedStyle","_getComputedStyle","e","_numbersExp","_isEdge","navigator","userAgent","indexOf","_types","rect","circle","ellipse","line","getDistance","x1","y1","x2","y2","scaleX","scaleY","parseFloat","Math","sqrt","unwrap","element","nodeType","TweenLite","selector","length","getLength","bbox","points","prevPoint","i","rx","ry","type","tagName","toLowerCase","getAttribute","getScreenCTM","a","b","d","c","getBBox","console","log","width","height","x","y","abs","style","strokeDasharray","getTotalLength","match","push","PI","getPosition","cs","dash","offset","strokeDashoffset","substr","max","_gsDefine","plugin","propName","API","version","global","overwriteProps","init","target","value","tween","index","start","end","overage","this","_style","_target","defaultStart","s","undefined","parse","_length","_dash","_offset","_offsetPT","_addTween","_dashPT","strokeLinecap","strokeLinejoin","strokeMiterlimit","_live","set","ratio","_firstPT","lengthRatio","_super","setRatio","call","process","env","IS_BROWSER","require","VideoControls","props","videoControlsWrapper","createRef","whiteCircle","progressCircle","hitArea","playButton","playText","pauseButton","pauseText","videoControls","draggable","progressCirclePath","timeRanges","showControls","hideControls","intervalId","initTimeRanges","bind","seekVideo","playVideo","onDragEndPlay","setProgress","handleVideoControlsMouseEnter","handleVideoControlsMouseLeave","handleVidControlWrapperEnter","handleVidControlWrapperLeave","animateControlButton","handleControlButtonMouseEnter","handleControlButtonMouseLeave","updateControlVisibility","state","dragging","svgWrapperHover","progressCircleTl","TimelineMax","paused","hoverTl","hoverVidControlWrapperTl","playPauseSwapTl","hoverPlayButtonTl","hoverPauseButtonTl","MorphSVGPlugin","convertToPath","current","TweenMax","rotation","svgOrigin","autoAlpha","Draggable","create","bounds","minRotation","maxRotation","onDrag","onDragEnd","from","drawSVG","ease","to","attr","r","fromTo","css","opacity","prevProps","prevState","snapshot","timeLineProgress","NaN","progress","videoPlaying","play","reverse","mousePosOnVid","ref","className","onMouseEnter","onMouseLeave","xmlns","viewBox","cx","cy","stroke","stroke-width","fill","onMouseOver","onMouseOut","onClick","class","clearInterval","setState","getVideoTimeRange","percent","setPercent","el","scale","transformOrigin","timer","setInterval","setTimeout","Component","Video","video","provideVideoTimeRange","videoPlayStatus","updateTimeLineProgress","updateVideoCurrentTime","handlePlay","handleVideoPlayEnded","handleMouseEnter","handleMouseLeave","handleMouseMove","handleMouseMoveThrottled","_throttle","mouseHovering","mousePos","addEventListener","ticker","removeEventListener","content","caption","poster","src","onPlay","onMouseMove","onEnded","mouseHoveringVideo","timeRangesObject","seekable","count","bool","pause","currentTime","duration","clientX","clientY","_lastLinkedAnchor","_PI","_DEG2RAD","_svgPathExp","_selectorExp","_commands","_scientific","_atan2","atan2","_cos","cos","_sin","sin","_sqrt","_2PI","_angleMin","_angleMax","globals","_log","message","_arcToBeziers","lastX","lastY","angle","largeArcFlag","sweepFlag","angleRad","cosAngle","sinAngle","dx2","dy2","x1_sq","y1_sq","radiiCheck","rx_sq","ry_sq","sq","coef","cx1","cy1","ux","uy","vx","vy","temp","angleStart","acos","angleExtent","isNaN","segments","ceil","rawPath","angleIncrement","controlLength","ma","mb","mc","md","_stringToRawPath","j","command","isRelative","segment","startX","startY","difX","difY","beziers","prevCommand","replace","m","n","path","relativeX","relativeY","elements","errorMessage","sx","sy","ex","ey","toUpperCase","closed","pop","totalPoints","_subdivideSegment","quantity","ax","ay","cp1x","cp1y","cp2x","cp2y","bx","by","t","tally","l","newPointsPerSegment","floor","splice","_rawPathToString","precision","rnd","pow","_reverseBezier","reversed","_getAverageXY","_getSize","xMax","xMin","yMax","yMin","centerX","centerY","size","_getTotalSize","samplesPerBezier","k","inv","x3","x4","y3","y4","inc","left","top","_sortByComplexity","_sortBySize","sizeA","sizeB","_offsetSegment","shapeIndex","slice","wrap","_getTotalMovement","sb","eb","offsetX","offsetY","_getClosestShapeIndex","checkReverse","copy","sCenter","eCenter","min","minIndex","_getClosestAnchor","dx","dy","closestDistance","closestX","closestY","_getClosestSegment","bezier","pool","startIndex","sortRatio","minSize","_equalizeSegmentQuantity","map","fillSafe","dif","longer","shorter","added","sortMethod","shapeIndices","sort","join","_equalizePointQuantity","factor","nextX","nextY","toFixed","_pointsFilter","startNums","endNums","_buildPointsFilter","text","parseInt","_offsetPoints","_typeAttrs","_convertToPath","swap","data","rcirc","rycirc","w","h","x5","x6","y5","y6","circ","ignore","name","createElementNS","Array","prototype","attributes","nodeName","setAttributeNS","nodeValue","_createPath","attrs","split","obj","_attrToObj","shift","setAttribute","_gsRawPath","parentNode","insertBefore","removeChild","_parseShape","shape","forcePath","isString","test","getAttributeNS","_populateSmoothData","tolerance","smooth","a2","isSmooth","smoothData","limit","_parseOriginFactors","v","trim","_morphMessage","p","pt","isPoly","startSmooth","endSmooth","startSeg","endSeg","precompiled","sData","eData","originFactors","useRotation","fillRule","origins","origin","prop","defaultMap","_prop","_render","render","defaultRender","_apply","updateTarget","defaultUpdateTarget","_rnd","_tween","precompile","defaultType","smoothTolerance","_origin","_eOrigin","_rawPath","_controlPT","_next","l1s","l1c","l2s","l2c","_tweenRotation","_overwriteProps","endProp","easeInOut","controlPT","anchorPT","_anchorPT","sa","ca","sl","cl","linkedPT","angleDif","short","so","eo","pathFilter","pointsFilter","getTotalSize","subdivideRawBezier","subdivideSegment","rawPathToString","stringToRawPath","pathDataToRawBezier","equalizeSegmentQuantity","targets","pathDataToBezier","vars","matrix","prefix","align","relative"],"mappings":"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","file":"4.10c4d9ff.js","sourcesContent":["/*!\n * VERSION: 0.2.1\n * DATE: 2019-02-07\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.\n * DrawSVGPlugin is a Club GreenSock membership benefit; You must have a valid membership to use\n * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.\n * This work is subject to the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n */\n/* eslint-disable */\n\nimport { _gsScope } from \"gsap/TweenLite.js\";\n\nvar _doc = _gsScope.document,\n\t\t_computedStyleScope = (typeof(window) !== \"undefined\" ? window : _doc.defaultView || {getComputedStyle:function() {}}),\n\t\t_getComputedStyle = function(e) {\n\t\t\treturn _computedStyleScope.getComputedStyle(e); //to avoid errors in Microsoft Edge, we need to call getComputedStyle() from a specific scope, typically window.\n\t\t},\n\t\t_numbersExp = /(?:(-|-=|\\+=)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t\t_isEdge = (((_gsScope.navigator || {}).userAgent || \"\").indexOf(\"Edge\") !== -1), //Microsoft Edge has a bug that causes it not to redraw the path correctly if the stroke-linecap is anything other than \"butt\" (like \"round\") and it doesn't match the stroke-linejoin. A way to trigger it is to change the stroke-miterlimit, so we'll only do that if/when we have to (to maximize performance)\n\t\t_types = {rect:[\"width\",\"height\"], circle:[\"r\",\"r\"], ellipse:[\"rx\",\"ry\"], line:[\"x2\",\"y2\"]},\n\t\tDrawSVGPlugin;\n\n\tfunction getDistance(x1, y1, x2, y2, scaleX, scaleY) {\n\t\tx2 = (parseFloat(x2 || 0) - parseFloat(x1 || 0)) * scaleX;\n\t\ty2 = (parseFloat(y2 || 0) - parseFloat(y1 || 0)) * scaleY;\n\t\treturn Math.sqrt(x2 * x2 + y2 * y2);\n\t}\n\n\tfunction unwrap(element) {\n\t\tif (typeof(element) === \"string\" || !element.nodeType) {\n\t\t\telement = _gsScope.TweenLite.selector(element);\n\t\t\tif (element.length) {\n\t\t\t\telement = element[0];\n\t\t\t}\n\t\t}\n\t\treturn element;\n\t}\n\n\t//accepts values like \"100%\" or \"20% 80%\" or \"20 50\" and parses it into an absolute start and end position on the line/stroke based on its length. Returns an an array with the start and end values, like [0, 243]\n\tfunction parse(value, length, defaultStart) {\n\t\tvar i = value.indexOf(\" \"),\n\t\t\ts, e;\n\t\tif (i === -1) {\n\t\t\ts = defaultStart !== undefined ? defaultStart + \"\" : value;\n\t\t\te = value;\n\t\t} else {\n\t\t\ts = value.substr(0, i);\n\t\t\te = value.substr(i+1);\n\t\t}\n\t\ts = (s.indexOf(\"%\") !== -1) ? (parseFloat(s) / 100) * length : parseFloat(s);\n\t\te = (e.indexOf(\"%\") !== -1) ? (parseFloat(e) / 100) * length : parseFloat(e);\n\t\treturn (s > e) ? [e, s] : [s, e];\n\t}\n\n\tfunction getLength(element) {\n\t\tif (!element) {\n\t\t\treturn 0;\n\t\t}\n\t\telement = unwrap(element);\n\t\tvar type = element.tagName.toLowerCase(),\n\t\t\tscaleX = 1,\n\t\t\tscaleY = 1,\n\t\t\tlength, bbox, points, prevPoint, i, rx, ry;\n\t\tif (element.getAttribute(\"vector-effect\") === \"non-scaling-stroke\") { //non-scaling-stroke basically scales the shape and then strokes it at the screen-level (after transforms), thus we need to adjust the length accordingly.\n\t\t\tscaleY = element.getScreenCTM();\n\t\t\tscaleX = Math.sqrt(scaleY.a * scaleY.a + scaleY.b * scaleY.b);\n\t\t\tscaleY = Math.sqrt(scaleY.d * scaleY.d + scaleY.c * scaleY.c);\n\t\t}\n\t\ttry { //IE bug: calling <path>.getTotalLength() locks the repaint area of the stroke to whatever its current dimensions are on that frame/tick. To work around that, we must call getBBox() to force IE to recalculate things.\n\t\t\tbbox = element.getBBox(); //solely for fixing bug in IE - we don't actually use the bbox.\n\t\t} catch (e) {\n\t\t\t//firefox has a bug that throws an error if the element isn't visible.\n\t\t\tconsole.log(\"Error: Some browsers like Firefox won't report measurements of invisible elements (like display:none or masks inside defs).\");\n\t\t}\n\t\tif ((!bbox || (!bbox.width && !bbox.height)) && _types[type]) { //if the element isn't visible, try to discern width/height using its attributes.\n\t\t\tbbox = {\n\t\t\t\twidth: parseFloat( element.getAttribute(_types[type][0]) ),\n\t\t\t\theight: parseFloat( element.getAttribute(_types[type][1]) )\n\t\t\t};\n\t\t\tif (type !== \"rect\" && type !== \"line\") { //double the radius for circles and ellipses\n\t\t\t\tbbox.width *= 2;\n\t\t\t\tbbox.height *= 2;\n\t\t\t}\n\t\t\tif (type === \"line\") {\n\t\t\t\tbbox.x = parseFloat( element.getAttribute(\"x1\") );\n\t\t\t\tbbox.y = parseFloat( element.getAttribute(\"y1\") );\n\t\t\t\tbbox.width = Math.abs(bbox.width - bbox.x);\n\t\t\t\tbbox.height = Math.abs(bbox.height - bbox.y);\n\t\t\t}\n\t\t}\n\t\tif (type === \"path\") {\n\t\t\tprevPoint = element.style.strokeDasharray;\n\t\t\telement.style.strokeDasharray = \"none\";\n\t\t\tlength = element.getTotalLength() || 0;\n\t\t\tif (scaleX !== scaleY) {\n\t\t\t\tconsole.log(\"Warning: <path> length cannot be measured accurately when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.\");\n\t\t\t}\n\t\t\tlength *= (scaleX + scaleY) / 2;\n\t\t\telement.style.strokeDasharray = prevPoint;\n\t\t} else if (type === \"rect\") {\n\t\t\tlength = bbox.width * 2 * scaleX + bbox.height * 2 * scaleY;\n\t\t} else if (type === \"line\") {\n\t\t\tlength = getDistance(bbox.x, bbox.y, bbox.x + bbox.width, bbox.y + bbox.height, scaleX, scaleY);\n\t\t} else if (type === \"polyline\" || type === \"polygon\") {\n\t\t\tpoints = element.getAttribute(\"points\").match(_numbersExp) || [];\n\t\t\tif (type === \"polygon\") {\n\t\t\t\tpoints.push(points[0], points[1]);\n\t\t\t}\n\t\t\tlength = 0;\n\t\t\tfor (i = 2; i < points.length; i+=2) {\n\t\t\t\tlength += getDistance(points[i-2], points[i-1], points[i], points[i+1], scaleX, scaleY) || 0;\n\t\t\t}\n\t\t} else if (type === \"circle\" || type === \"ellipse\") {\n\t\t\trx = (bbox.width / 2) * scaleX;\n\t\t\try = (bbox.height / 2) * scaleY;\n\t\t\tlength = Math.PI * ( 3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)) );\n\t\t}\n\t\treturn length || 0;\n\t}\n\n\tfunction getPosition(element, length) {\n\t\tif (!element) {\n\t\t\treturn [0, 0];\n\t\t}\n\t\telement = unwrap(element);\n\t\tlength = length || (getLength(element) + 1);\n\t\tvar cs = _getComputedStyle(element),\n\t\t\tdash = cs.strokeDasharray || \"\",\n\t\t\toffset = parseFloat(cs.strokeDashoffset),\n\t\t\ti = dash.indexOf(\",\");\n\t\tif (i < 0) {\n\t\t\ti = dash.indexOf(\" \");\n\t\t}\n\t\tdash = (i < 0) ? length : parseFloat(dash.substr(0, i)) || 0.00001;\n\t\tif (dash > length) {\n\t\t\tdash = length;\n\t\t}\n\t\treturn [Math.max(0, -offset), Math.max(0, dash - offset)];\n\t}\n\n\tDrawSVGPlugin = _gsScope._gsDefine.plugin({\n\t\tpropName: \"drawSVG\",\n\t\tAPI: 2,\n\t\tversion: \"0.2.1\",\n\t\tglobal: true,\n\t\toverwriteProps: [\"drawSVG\"],\n\n\t\tinit: function(target, value, tween, index) {\n\t\t\tif (!target.getBBox) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar length = getLength(target) + 1,\n\t\t\t\tstart, end, overage, cs;\n\t\t\tthis._style = target.style;\n\t\t\tthis._target = target;\n\t\t\tif (typeof(value) === \"function\") {\n\t\t\t\tvalue = value(index, target);\n\t\t\t}\n\t\t\tif (value === true || value === \"true\") {\n\t\t\t\tvalue = \"0 100%\";\n\t\t\t} else if (!value) {\n\t\t\t\tvalue = \"0 0\";\n\t\t\t} else if ((value + \"\").indexOf(\" \") === -1) {\n\t\t\t\tvalue = \"0 \" + value;\n\t\t\t}\n\t\t\tstart = getPosition(target, length);\n\t\t\tend = parse(value, length, start[0]);\n\t\t\tthis._length = length + 10;\n\t\t\tif (start[0] === 0 && end[0] === 0) {\n\t\t\t\toverage = Math.max(0.00001, end[1] - length); //allow people to go past the end, like values of 105% because for some paths, Firefox doesn't return an accurate getTotalLength(), so it could end up coming up short.\n\t\t\t\tthis._dash = length + overage;\n\t\t\t\tthis._offset = length - start[1] + overage;\n\t\t\t\tthis._offsetPT = this._addTween(this, \"_offset\", this._offset, length - end[1] + overage, \"drawSVG\");\n\t\t\t} else {\n\t\t\t\tthis._dash = (start[1] - start[0]) || 0.000001; //some browsers render artifacts if dash is 0, so we use a very small number in that case.\n\t\t\t\tthis._offset = -start[0];\n\t\t\t\tthis._dashPT = this._addTween(this, \"_dash\", this._dash, (end[1] - end[0]) || 0.00001, \"drawSVG\");\n\t\t\t\tthis._offsetPT = this._addTween(this, \"_offset\", this._offset, -end[0], \"drawSVG\");\n\t\t\t}\n\t\t\tif (_isEdge) { //to work around a bug in Microsoft Edge, animate the stroke-miterlimit by 0.0001 just to trigger the repaint (unnecessary if it's \"round\" and stroke-linejoin is also \"round\"). Imperceptible, relatively high-performance, and effective. Another option was to set the \"d\" <path> attribute to its current value on every tick, but that seems like it'd be much less performant.\n\t\t\t\tcs = _getComputedStyle(target);\n\t\t\t\tif (cs.strokeLinecap !== cs.strokeLinejoin) {\n\t\t\t\t\tend = parseFloat(cs.strokeMiterlimit);\n\t\t\t\t\tthis._addTween(target.style, \"strokeMiterlimit\", end, end + 0.0001, \"strokeMiterlimit\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._live = (target.getAttribute(\"vector-effect\") === \"non-scaling-stroke\" || (value + \"\").indexOf(\"live\") !== -1);\n\t\t\treturn true;\n\t\t},\n\n\t\t//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)\n\t\tset: function(ratio) {\n\t\t\tif (this._firstPT) {\n\t\t\t\t//when the element has vector-effect=\"non-scaling-stroke\" and the SVG is resized (like on a window resize), it actually changes the length of the stroke! So we must sense that and make the proper adjustments.\n\t\t\t\tif (this._live) {\n\t\t\t\t\tvar length = getLength(this._target) + 11,\n\t\t\t\t\t\tlengthRatio;\n\t\t\t\t\tif (length !== this._length) {\n\t\t\t\t\t\tlengthRatio = length / this._length;\n\t\t\t\t\t\tthis._length = length;\n\t\t\t\t\t\tthis._offsetPT.s *= lengthRatio;\n\t\t\t\t\t\tthis._offsetPT.c *= lengthRatio;\n\t\t\t\t\t\tif (this._dashPT) {\n\t\t\t\t\t\t\tthis._dashPT.s *= lengthRatio;\n\t\t\t\t\t\t\tthis._dashPT.c *= lengthRatio;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._dash *= lengthRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._super.setRatio.call(this, ratio);\n\t\t\t\tthis._style.strokeDashoffset = this._offset;\n\t\t\t\tif (ratio === 1 || ratio === 0) {\n\t\t\t\t\tthis._style.strokeDasharray = (this._offset < 0.001 && this._length - this._dash <= 10) ? \"none\" : (this._offset === this._dash) ? \"0px, 999999px\" : this._dash + \"px,\" + this._length + \"px\";\n\t\t\t\t} else {\n\t\t\t\t\tthis._style.strokeDasharray = this._dash + \"px,\" + this._length + \"px\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t});\n\n\tDrawSVGPlugin.getLength = getLength;\n\tDrawSVGPlugin.getPosition = getPosition;\n\nexport { DrawSVGPlugin, DrawSVGPlugin as default };","import React, { Component, createRef } from 'react';\nimport './assets/css/video-controls.css';\nimport _throttle from 'lodash/throttle';\nimport _debounce from 'lodash/debounce';\n\nif (process.env.IS_BROWSER) {\n  const TweenMax = require('gsap/TweenMax');\n  const TimelineMax = require('gsap/TimelineMax');\n  const AttrPlugin = require('gsap/AttrPlugin');\n  const Draggable = require('gsap/Draggable');\n  const MorphSVGPlugin = require('./assets/utils/MorphSVGPlugin');\n  const DrawSVGPlugin = require('./assets/utils/DrawSVGPlugin');\n}\n\nexport default class VideoControls extends Component {\n\n  constructor(props) {\n    super(props);\n\n    this.videoControlsWrapper = createRef();\n    this.whiteCircle = createRef();\n    this.progressCircle = createRef();\n    this.hitArea = createRef();\n    this.playButton = createRef();\n    this.playText = createRef();\n    this.pauseButton = createRef();\n    this.pauseText = createRef();\n    this.videoControls = createRef();\n\n    this.draggable;\n    this.progressCirclePath;\n    this.timeRanges;\n    this.showControls;\n    this.hideControls;\n    this.intervalId = 0;\n\n    this.initTimeRanges = this.initTimeRanges.bind(this);\n    this.seekVideo = this.seekVideo.bind(this);\n    this.playVideo = this.playVideo.bind(this);\n    this.onDragEndPlay = this.onDragEndPlay.bind(this);\n    this.setProgress = this.setProgress.bind(this);\n    this.handleVideoControlsMouseEnter = this.handleVideoControlsMouseEnter.bind(this);\n    this.handleVideoControlsMouseLeave = this.handleVideoControlsMouseLeave.bind(this);\n    this.handleVidControlWrapperEnter = this.handleVidControlWrapperEnter.bind(this);\n    this.handleVidControlWrapperLeave = this.handleVidControlWrapperLeave.bind(this);\n\n    this.animateControlButton = this.animateControlButton.bind(this);\n    this.handleControlButtonMouseEnter = this.handleControlButtonMouseEnter.bind(this);\n    this.handleControlButtonMouseLeave = this.handleControlButtonMouseLeave.bind(this);\n    this.updateControlVisibility = this.updateControlVisibility.bind(this);\n\n    this.state = {\n      dragging: false,\n      timeRanges: null,\n      svgWrapperHover: false\n    };\n\n  }\n\n  componentDidMount() {\n\n    if (process.env.IS_BROWSER) {\n\n      this.progressCircleTl = new TimelineMax({ paused: true });\n      this.hoverTl = new TimelineMax({ paused: true });\n\n      this.hoverVidControlWrapperTl = new TimelineMax({ paused: true });\n\n      this.playPauseSwapTl = new TimelineMax({ paused: true });\n      this.hoverPlayButtonTl = new TimelineMax({ paused: true });\n      this.hoverPauseButtonTl = new TimelineMax({ paused: true });\n\n        this.progressCirclePath = MorphSVGPlugin.convertToPath(this.progressCircle.current);\n\n        TweenMax.set(this.videoControls.current, { rotation: 0, svgOrigin: \"150, 150\" });\n        TweenMax.set(this.pauseButton.current, { autoAlpha: 0 });\n\n        this.draggable = Draggable.create(this.videoControls.current, {\n          type: \"rotation\",\n          bounds: { minRotation: 0, maxRotation: 360 },\n          onDrag: this.seekVideo,\n          onDragEnd: this.onDragEndPlay\n        });\n\n        this.progressCircleTl\n          .from(this.progressCirclePath, 0.5, { drawSVG: \"0%\", ease: \"Power0.easeNone\" })\n          .to(this.videoControls.current, 0.5, { rotation: 360, ease: \"Power0.easeNone\" }, 0);\n\n        this.hoverTl\n         .to(this.videoControls.current, 0.5, { attr: { r: 8 } });\n\n        this.playPauseSwapTl\n          .fromTo(this.playButton.current, 0.5, { autoAlpha: 1 }, { autoAlpha: 0 })\n          .fromTo(this.pauseButton.current, 0.5, { autoAlpha: 0 }, { autoAlpha: 1 }, 0);\n\n        this.hoverVidControlWrapperTl\n          .to([this.videoControls.current, this.hitArea.current], 0.5, { attr: { r: 6 } })\n          .fromTo(this.whiteCircle.current, 0.5, { css: { opacity: 0.25 } }, { css: { opacity: 1 } }, 0)\n\n        this.showControls = () => TweenMax.to([this.videoControlsWrapper.current, this.hitArea.current], 3, { css: {opacity: 1} });\n        this.hideControls = () => TweenMax.to([this.videoControlsWrapper.current, this.hitArea.current], 3, { css: {opacity: 0} });\n\n    }\n\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    if (process.env.IS_BROWSER) {\n      if ( (prevProps.timeLineProgress !== this.props.timeLineProgress) && this.props.timeLineProgress !== NaN ) {\n        this.progressCircleTl.progress( this.props.timeLineProgress );\n      }\n\n      if (prevProps.videoPlaying !== this.props.videoPlaying) { // this is only going to fire once, when the video changes state from playing to paused and vice versa\n        if (this.props.videoPlaying) {\n          this.playPauseSwapTl.play();\n        } else {\n          this.showControls();\n          this.playPauseSwapTl.reverse();\n        }\n      }\n\n      if (prevProps.mousePosOnVid !== this.props.mousePosOnVid) {\n        if (this.props.videoPlaying) { this.updateControlVisibility(); }\n      }\n    }\n  }\n\n\n  render() {\n\n    const playPauseText = () => !this.props.videoPlaying ? <span ref={ this.playText }>PLAY</span> : <span ref={ this.pauseText }>PAUSE</span>;\n\n\n    return (\n      <>\n      <div ref={ this.videoControlsWrapper } className=\"video-controls-wrapper\" onMouseEnter={ this.handleVidControlWrapperEnter } onMouseLeave={ this.handleVidControlWrapperLeave }>\n      <svg className=\"video-controls\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 300 300\">\n\n        <circle ref={ this.whiteCircle } className=\"st0\" cx=\"150\" cy=\"150\" r=\"75\" />\n        <circle ref={ this.progressCircle } stroke=\"green\" stroke-width=\"3\" fill=\"none\" cx=\"150\" cy=\"150\" r=\"75\"  />\n        <circle ref={ this.videoControls } className=\"video-controls-component\" stroke=\"green\" stroke-width=\"1\" fill=\"green\" cx=\"225\" cy=\"150\" r=\"4\" onMouseOver={ this.handleVideoControlsMouseEnter } onMouseOut={ this.handleVideoControlsMouseLeave } />\n\n      </svg>\n\n        { this.state.dragging === false ? <p onClick={ this.playVideo }>{ playPauseText() } VIDEO</p> : <p>SEEKING</p> }\n      </div>\n\n      <div className=\"hit-area\" ref={ this.hitArea } onMouseEnter={ this.handleControlButtonMouseEnter } onMouseLeave={ this.handleControlButtonMouseLeave } onClick={ this.playVideo }>\n\n        <svg className=\"video-controls-play-button\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"-20 -20 200 200\">\n        <g className=\"button\" ref={ this.playButton }>\n          <polygon class=\"st0\" points=\"16.85,20.41 15.73,13.06 25.75,20.41 15.73,27.76 \t\"/>\n          <path class=\"st0\" d=\"M16.41,14.18l8.5,6.23l-8.5,6.23l0.92-6.08l0.02-0.15l-0.02-0.15L16.41,14.18 M15.06,11.95l1.28,8.46l-1.28,8.46l11.54-8.46L15.06,11.95L15.06,11.95z\"/>\n        </g>\n\n        <g className=\"button\" ref={ this.pauseButton }>\n          <g>\n            <rect x=\"13.1\" y=\"10.91\" class=\"st0\" width=\"4\" height=\"19\"/>\n            <path class=\"st0\" d=\"M16.6,11.41v18h-3v-18H16.6 M17.6,10.41h-5v20h5V10.41L17.6,10.41z\"/>\n          </g>\n          <g>\n            <rect x=\"21.86\" y=\"10.91\" class=\"st0\" width=\"4\" height=\"19\"/>\n            <path class=\"st0\" d=\"M25.36,11.41v18h-3v-18H25.36 M26.36,10.41h-5v20h5V10.41L26.36,10.41z\"/>\n          </g>\n        </g>\n        </svg>\n      </div>\n      </>\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.intervalId);\n  }\n\n  initTimeRanges() {\n    this.setState({ timeRanges: this.props.getVideoTimeRange() });\n  }\n\n  playVideo() {\n    this.state.timeRanges === null ? this.initTimeRanges() : null;\n    this.props.playVideo(!this.props.videoPlaying);\n  }\n\n  onDragEndPlay() {\n    this.props.playVideo(true);\n    this.setState({ dragging: false });\n  }\n\n  seekVideo() {\n    this.playVideo();\n    this.setProgress( this.draggable[0].rotation / 360 );\n    this.setState({ dragging: true });\n  }\n\n  setProgress(percent) {\n    this.props.setPercent(percent);\n  }\n\n  handleVideoControlsMouseEnter() {\n    this.hoverTl.play();\n  }\n\n  handleVideoControlsMouseLeave() {\n    this.hoverTl.reverse();\n  }\n\n  handleVidControlWrapperEnter() {\n    this.hoverVidControlWrapperTl.play();\n    this.showControls();\n    this.setState({ svgWrapperHover: true });\n  }\n\n  handleVidControlWrapperLeave() {\n    this.hoverVidControlWrapperTl.reverse();\n    this.setState({ svgWrapperHover: false });\n  }\n\n  animateControlButton(el) {\n    return this.hoverPlayButtonTl.to(el.current, 0.5, { css: { scale: 1.75, transformOrigin: \"center center\" } });\n  }\n\n  handleControlButtonMouseEnter() {\n    let el = this.props.videoPlaying ? this.pauseButton : this.playButton;\n    this.animateControlButton(el).play();\n    this.showControls();\n    this.setState({ svgWrapperHover: true });\n  }\n\n  handleControlButtonMouseLeave() {\n    let el = this.props.videoPlaying ? this.pauseButton : this.playButton;\n    this.animateControlButton(el).reverse();\n    this.setState({ svgWrapperHover: false });\n  }\n\n  updateControlVisibility() {\n    var timer = 3;\n    this.showControls();\n\n    this.intervalId = setInterval(\n      () => {\n        if (timer > 0) {\n          timer = timer - 1;\n        }\n      },\n    1000);\n\n    setTimeout(\n      () => {\n        clearInterval(this.intervalId);\n        if (this.props.videoPlaying && !this.state.svgWrapperHover) {\n          this.hideControls();\n        } else {\n          this.showControls()\n        }\n      },\n    3500);\n\n  }\n\n};\n","import React, { Component, createRef } from 'react';\nimport VideoControls from './VideoControls';\nimport _throttle from 'lodash/throttle';\n\nif (process.env.IS_BROWSER) {\n  const TweenLite = require('gsap/TweenLite');\n}\n\nexport default class Video extends Component {\n\n  constructor(props) {\n    super(props);\n\n    this.timeRanges = [];\n    this.video = createRef();\n\n    this.provideVideoTimeRange = this.provideVideoTimeRange.bind(this);\n    this.videoPlayStatus = this.videoPlayStatus.bind(this);\n    this.updateTimeLineProgress = this.updateTimeLineProgress.bind(this);\n    this.updateVideoCurrentTime = this.updateVideoCurrentTime.bind(this);\n    this.handlePlay = this.handlePlay.bind(this);\n    this.handleVideoPlayEnded = this.handleVideoPlayEnded.bind(this);\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\n    this.handleMouseLeave = this.handleMouseLeave.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n\n    this.handleMouseMoveThrottled = _throttle(this.handleMouseMove, 1000, { 'leading': true, 'trailing': false });\n\n\n    this.state = {\n      timeLineProgress: 0,\n      mouseHovering: false,\n      videoPlaying: false,\n      mousePos: [0, 0]\n    };\n  }\n\n  componentDidMount() {\n    this.video.current.addEventListener('timeupdate', this.updateTimeLineProgress);\n  }\n\n  componentWillUnmount() {\n    TweenLite.ticker.removeEventListener('tick', this.updateTimeLineProgress);\n    this.video.current.removeEventListener('timeupdate', this.updateTimeLineProgress);\n  }\n\n  render() {\n    const { caption, poster, src } = this.props.content;\n\n    return (\n      <>\n        <video ref={ this.video } poster={poster} onPlay={ this.handlePlay } onMouseEnter={ this.handleMouseEnter } onMouseLeave={ this.handleMouseLeave } onMouseMove={ this.handleMouseMoveThrottled } onEnded={ this.handleVideoPlayEnded }>\n          <source src={src} />\n        </video>\n        <VideoControls\n          getVideoTimeRange={ this.provideVideoTimeRange }\n          playVideo={ this.videoPlayStatus }\n          videoPlaying={ this.state.videoPlaying }\n          mouseHoveringVideo={ this.state.mouseHovering }\n          timeLineProgress={ this.state.timeLineProgress }\n          setPercent={ this.updateVideoCurrentTime }\n          mousePosOnVid={ this.state.mousePos }\n        />\n        <span className=\"vid-time\">00:00</span>\n        <p>{caption}</p>\n      </>\n    );\n  }\n\n  handlePlay() {\n    TweenLite.ticker.addEventListener('tick', this.updateTimeLineProgress);\n  }\n\n  provideVideoTimeRange() {\n    const timeRangesObject = this.video.current.seekable;\n    for (let count = 0; count < timeRangesObject.length; count++) {\n      this.timeRanges.push([timeRangesObject.start(count), timeRangesObject.end(count)]);\n    }\n    return this.timeRanges;\n  }\n\n  videoPlayStatus(bool) {\n    if (bool) {\n      this.video.current.play();\n      this.setState({ videoPlaying: true });\n    } else {\n      this.video.current.pause();\n      this.setState({ videoPlaying: false });\n    }\n  }\n\n  updateTimeLineProgress() {\n    this.setState({ timeLineProgress: (this.video.current.currentTime / this.video.current.duration) });\n  }\n\n  updateVideoCurrentTime(percent) {\n    this.video.current.currentTime = ( this.timeRanges[0][1] * percent );\n  }\n\n  handleVideoPlayEnded() {\n    this.setState({ videoPlaying: false });\n  }\n\n  handleMouseEnter() {\n    this.setState({ mouseHovering: true });\n  }\n\n  handleMouseLeave() {\n    this.setState({ mouseHovering: false });\n  }\n\n\n  handleMouseMove(e) {\n    if (e.clientX !== null && e.clientY !== null) {\n      this.setState({ mousePos: [e.clientX, e.clientY] });\n    }\n  }\n\n};\n","/*!\n * VERSION: 0.9.2\n * DATE: 2019-08-13\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.\n * MorphSVGPlugin is a Club GreenSock membership benefit; You must have a valid membership to use\n * this code without violating the terms of use. Visit http://greensock.com/club/ to sign up or get more details.\n * This work is subject to the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n */\n/* eslint-disable */\n\nimport { _gsScope } from \"gsap/TweenLite.js\";\n\n\tvar _PI = Math.PI,\n\t\t_DEG2RAD = _PI / 180,\n\t\t_svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t\t_numbersExp = /(?:(-|-=|\\+=)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t\t_selectorExp = /(^[#\\.][a-z]|[a-y][a-z])/i,\n\t\t_commands = /[achlmqstvz]/ig,\n\t\t_scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig,\n\t\t_atan2 = Math.atan2,\n\t\t_cos = Math.cos,\n\t\t_sin = Math.sin,\n\t\t_sqrt = Math.sqrt,\n\t\t_2PI = _PI * 2,\n\t\t_angleMin = _PI * 0.3,\n\t\t_angleMax = _PI * 0.7,\n\t\t_bigNum = 1e20,\n\t\t_lastLinkedAnchor,\n\t\tTweenLite = _gsScope._gsDefine.globals.TweenLite,\n\n\t\t_log = function(message) {\n\t\t\tif (_gsScope.console) {\n\t\t\t\tconsole.log(message);\n\t\t\t}\n\t\t},\n\n\t\t// translates SVG arc data into an array of cubic beziers\n\t\t_arcToBeziers = function(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n\t\t\tif (lastX === x && lastY === y) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trx = Math.abs(rx);\n\t\t\try = Math.abs(ry);\n\t\t\tvar angleRad = (angle % 360) * _DEG2RAD,\n\t\t\t\tcosAngle = _cos(angleRad),\n\t\t\t\tsinAngle = _sin(angleRad),\n\t\t\t\tdx2 = (lastX - x) / 2,\n\t\t\t\tdy2 = (lastY - y) / 2,\n\t\t\t\tx1 = (cosAngle * dx2 + sinAngle * dy2),\n\t\t\t\ty1 = (-sinAngle * dx2 + cosAngle * dy2),\n\t\t\t\tx1_sq = x1 * x1,\n\t\t\t\ty1_sq = y1 * y1,\n\t\t\t\tradiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);\n\t\t\tif (radiiCheck > 1) {\n\t\t\t\trx = _sqrt(radiiCheck) * rx;\n\t\t\t\try = _sqrt(radiiCheck) * ry;\n\t\t\t}\n\t\t\tvar rx_sq = rx * rx,\n\t\t\t\try_sq = ry * ry,\n\t\t\t\tsq = ((rx_sq * ry_sq) - (rx_sq * y1_sq) - (ry_sq * x1_sq)) / ((rx_sq * y1_sq) + (ry_sq * x1_sq));\n\t\t\tif (sq < 0) {\n\t\t\t\tsq = 0;\n\t\t\t}\n\t\t\tvar coef = ((largeArcFlag === sweepFlag) ? -1 : 1) * _sqrt(sq),\n\t\t\t\tcx1 = coef * ((rx * y1) / ry),\n\t\t\t\tcy1 = coef * -((ry * x1) / rx),\n\t\t\t\tsx2 = (lastX + x) / 2,\n\t\t\t\tsy2 = (lastY + y) / 2,\n\t\t\t\tcx = sx2 + (cosAngle * cx1 - sinAngle * cy1),\n\t\t\t\tcy = sy2 + (sinAngle * cx1 + cosAngle * cy1),\n\t\t\t\tux = (x1 - cx1) / rx,\n\t\t\t\tuy = (y1 - cy1) / ry,\n\t\t\t\tvx = (-x1 - cx1) / rx,\n\t\t\t\tvy = (-y1 - cy1) / ry,\n\t\t\t\ttemp = ux * ux + uy * uy,\n\t\t\t\tangleStart = ((uy < 0) ? -1 : 1) * Math.acos(ux / _sqrt(temp)),\n\t\t\t\tangleExtent = ((ux * vy - uy * vx < 0) ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));\n\t\t\tif (isNaN(angleExtent)) { //rare edge case. Math.cos(-1) is NaN.\n\t\t\t\tangleExtent = _PI;\n\t\t\t}\n\t\t\tif (!sweepFlag && angleExtent > 0) {\n\t\t\t\tangleExtent -= _2PI;\n\t\t\t} else if (sweepFlag && angleExtent < 0) {\n\t\t\t\tangleExtent += _2PI;\n\t\t\t}\n\t\t\tangleStart %= _2PI;\n\t\t\tangleExtent %= _2PI;\n\t\t\tvar segments = Math.ceil(Math.abs(angleExtent) / (_2PI / 4)),\n\t\t\t\trawPath = [],\n\t\t\t\tangleIncrement = angleExtent / segments,\n\t\t\t\tcontrolLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),\n\t\t\t\tma = cosAngle * rx,\n\t\t\t\tmb = sinAngle * rx,\n\t\t\t\tmc = sinAngle * -ry,\n\t\t\t\tmd = cosAngle * ry,\n\t\t\t\ti;\n\t\t\tfor (i = 0; i < segments; i++) {\n\t\t\t\tangle = angleStart + i * angleIncrement;\n\t\t\t\tx1 = _cos(angle);\n\t\t\t\ty1 = _sin(angle);\n\t\t\t\tux = _cos(angle += angleIncrement);\n\t\t\t\tuy = _sin(angle);\n\t\t\t\trawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);\n\t\t\t}\n\t\t\t//now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).\n\t\t\tfor (i = 0; i < rawPath.length; i+=2) {\n\t\t\t\tx1 = rawPath[i];\n\t\t\t\ty1 = rawPath[i+1];\n\t\t\t\trawPath[i] = x1 * ma + y1 * mc + cx;\n\t\t\t\trawPath[i+1] = x1 * mb + y1 * md + cy;\n\t\t\t}\n\t\t\trawPath[i-2] = x; //always set the end to exactly where it's supposed to be\n\t\t\trawPath[i-1] = y;\n\t\t\treturn rawPath;\n\t\t},\n\n\t\t//Spits back an array of cubic Bezier segments that use absolute coordinates. Each segment starts with a \"moveTo\" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.\n\t\t_stringToRawPath = function(d) {\n\t\t\tvar a = (d + \"\").replace(_scientific, function(m) { var n = +m; return (n < 0.0001 && n > -0.0001) ? 0 : n; }).match(_svgPathExp) || [], //some authoring programs spit out very small numbers in scientific notation like \"1e-5\", so make sure we round that down to 0 first.\n\t\t\t\tpath = [],\n\t\t\t\trelativeX = 0,\n\t\t\t\trelativeY = 0,\n\t\t\t\ttwoThirds = 2 / 3,\n\t\t\t\telements = a.length,\n\t\t\t\tpoints = 0,\n\t\t\t\terrorMessage = \"ERROR: malformed path: \" + d,\n\t\t\t\tline = function(sx, sy, ex, ey) {\n\t\t\t\t\tdifX = (ex - sx) / 3;\n\t\t\t\t\tdifY = (ey - sy) / 3;\n\t\t\t\t\tsegment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);\n\t\t\t\t},\n\t\t\t\ti, j, x, y, command, isRelative, segment, startX, startY, difX, difY, beziers, prevCommand;\n\t\t\tif (!d || !isNaN(a[0]) || isNaN(a[1])) {\n\t\t\t\t_log(errorMessage);\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tfor (i = 0; i < elements; i++) {\n\t\t\t\tprevCommand = command;\n\t\t\t\tif (isNaN(a[i])) {\n\t\t\t\t\tcommand = a[i].toUpperCase();\n\t\t\t\t\tisRelative = (command !== a[i]); //lower case means relative\n\t\t\t\t} else { //commands like \"C\" can be strung together without any new command characters between.\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tx = +a[i + 1];\n\t\t\t\ty = +a[i + 2];\n\t\t\t\tif (isRelative) {\n\t\t\t\t\tx += relativeX;\n\t\t\t\t\ty += relativeY;\n\t\t\t\t}\n\t\t\t\tif (!i) {\n\t\t\t\t\tstartX = x;\n\t\t\t\t\tstartY = y;\n\t\t\t\t}\n\n\t\t\t\t// \"M\" (move)\n\t\t\t\tif (command === \"M\") {\n\t\t\t\t\tif (segment) {\n\t\t\t\t\t\tif (segment.length < 8) { //if the path data was funky and just had a M with no actual drawing anywhere, skip it.\n\t\t\t\t\t\t\tpath.length -= 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpoints += segment.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trelativeX = startX = x;\n\t\t\t\t\trelativeY = startY = y;\n\t\t\t\t\tsegment = [x, y];\n\t\t\t\t\tpath.push(segment);\n\t\t\t\t\ti += 2;\n\t\t\t\t\tcommand = \"L\"; //an \"M\" with more than 2 values gets interpreted as \"lineTo\" commands (\"L\").\n\n\t\t\t\t// \"C\" (cubic bezier)\n\t\t\t\t} else if (command === \"C\") {\n\t\t\t\t\tif (!segment) {\n\t\t\t\t\t\tsegment = [0, 0];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isRelative) {\n\t\t\t\t\t\trelativeX = relativeY = 0;\n\t\t\t\t\t}\n\t\t\t\t\t//note: \"*1\" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.\n\t\t\t\t\tsegment.push(x,\ty, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, (relativeX += a[i + 5] * 1),\t(relativeY += a[i + 6] * 1));\n\t\t\t\t\ti += 6;\n\n\t\t\t\t// \"S\" (continuation of cubic bezier)\n\t\t\t\t} else if (command === \"S\") {\n\t\t\t\t\tdifX = relativeX;\n\t\t\t\t\tdifY = relativeY;\n\t\t\t\t\tif (prevCommand === \"C\" || prevCommand === \"S\") {\n\t\t\t\t\t\tdifX += relativeX - segment[segment.length - 4];\n\t\t\t\t\t\tdifY += relativeY - segment[segment.length - 3];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isRelative) {\n\t\t\t\t\t\trelativeX = relativeY = 0;\n\t\t\t\t\t}\n\t\t\t\t\tsegment.push(difX, difY, x,\ty, (relativeX += a[i + 3] * 1), (relativeY += a[i + 4] * 1));\n\t\t\t\t\ti += 4;\n\n\t\t\t\t// \"Q\" (quadratic bezier)\n\t\t\t\t} else if (command === \"Q\") {\n\t\t\t\t\tdifX = relativeX + (x - relativeX) * twoThirds;\n\t\t\t\t\tdifY = relativeY + (y - relativeY) * twoThirds;\n\t\t\t\t\tif (!isRelative) {\n\t\t\t\t\t\trelativeX = relativeY = 0;\n\t\t\t\t\t}\n\t\t\t\t\trelativeX += a[i + 3] * 1;\n\t\t\t\t\trelativeY += a[i + 4] * 1;\n\t\t\t\t\tsegment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);\n\t\t\t\t\ti += 4;\n\n\t\t\t\t// \"T\" (continuation of quadratic bezier)\n\t\t\t\t} else if (command === \"T\") {\n\t\t\t\t\tdifX = relativeX - segment[segment.length - 4];\n\t\t\t\t\tdifY = relativeY - segment[segment.length - 3];\n\t\t\t\t\tsegment.push(relativeX + difX, relativeY + difY, x + ((relativeX + difX * 1.5) - x) * twoThirds, y + ((relativeY + difY * 1.5) - y) * twoThirds, (relativeX = x), (relativeY = y));\n\t\t\t\t\ti += 2;\n\n\t\t\t\t// \"H\" (horizontal line)\n\t\t\t\t} else if (command === \"H\") {\n\t\t\t\t\tline(relativeX, relativeY, (relativeX = x), relativeY);\n\t\t\t\t\ti += 1;\n\n\t\t\t\t// \"V\" (vertical line)\n\t\t\t\t} else if (command === \"V\") {\n\t\t\t\t\t//adjust values because the first (and only one) isn't x in this case, it's y.\n\t\t\t\t\tline(relativeX, relativeY, relativeX, (relativeY = x + (isRelative ? relativeY - relativeX : 0)));\n\t\t\t\t\ti += 1;\n\n\t\t\t\t// \"L\" (line) or \"Z\" (close)\n\t\t\t\t} else if (command === \"L\" || command === \"Z\") {\n\t\t\t\t\tif (command === \"Z\") {\n\t\t\t\t\t\tx = startX;\n\t\t\t\t\t\ty = startY;\n\t\t\t\t\t\tsegment.closed = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (command === \"L\" || Math.abs(relativeX - x) > 0.5 || Math.abs(relativeY - y) > 0.5) {\n\t\t\t\t\t\tline(relativeX, relativeY, x, y);\n\t\t\t\t\t\tif (command === \"L\") {\n\t\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trelativeX = x;\n\t\t\t\t\trelativeY = y;\n\n\t\t\t\t// \"A\" (arc)\n\t\t\t\t} else if (command === \"A\") {\n\t\t\t\t\tbeziers = _arcToBeziers(relativeX, relativeY, +a[i+1], +a[i+2], +a[i+3], +a[i+4], +a[i+5], (isRelative ? relativeX : 0) + a[i+6]*1, (isRelative ? relativeY : 0) + a[i+7]*1);\n\t\t\t\t\tif (beziers) {\n\t\t\t\t\t\tfor (j = 0; j < beziers.length; j++) {\n\t\t\t\t\t\t\tsegment.push(beziers[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trelativeX = segment[segment.length-2];\n\t\t\t\t\trelativeY = segment[segment.length-1];\n\t\t\t\t\ti += 7;\n\n\t\t\t\t} else {\n\t\t\t\t\t_log(errorMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = segment.length;\n\t\t\tif (i < 6) { //in case there's odd SVG like a M0,0 command at the very end.\n\t\t\t\tpath.pop();\n\t\t\t\ti = 0;\n\t\t\t} else if (segment[0] === segment[i-2] && segment[1] === segment[i-1]) {\n\t\t\t\tsegment.closed = true;\n\t\t\t}\n\t\t\tpath.totalPoints = points + i;\n\t\t\treturn path;\n\t\t},\n\n\t\t//adds a certain number of Beziers while maintaining the path shape (so that the start/end values can have a matching quantity of points to animate). Only pass in ONE segment of the Bezier at a time. Format: [xAnchor, yAnchor, xControlPoint1, yControlPoint1, xControlPoint2, yControlPoint2, xAnchor, yAnchor, xControlPoint1, etc...]\n\t\t_subdivideSegment = function(segment, quantity) {\n\t\t\tvar tally = 0,\n\t\t\t\tmax = 0.999999,\n\t\t\t\tl = segment.length,\n\t\t\t\tnewPointsPerSegment = quantity / ((l - 2) / 6),\n\t\t\t\tax, ay, cp1x, cp1y, cp2x, cp2y, bx, by,\n\t\t\t\tx1, y1, x2, y2, i, t;\n\t\t\tfor (i = 2; i < l; i += 6) {\n\t\t\t\ttally += newPointsPerSegment;\n\t\t\t\twhile (tally > max) { //compare with 0.99999 instead of 1 in order to prevent rounding errors\n\t\t\t\t\tax = segment[i-2];\n\t\t\t\t\tay = segment[i-1];\n\t\t\t\t\tcp1x = segment[i];\n\t\t\t\t\tcp1y = segment[i+1];\n\t\t\t\t\tcp2x = segment[i+2];\n\t\t\t\t\tcp2y = segment[i+3];\n\t\t\t\t\tbx = segment[i+4];\n\t\t\t\t\tby = segment[i+5];\n\t\t\t\t\tt = 1 / ((Math.floor(tally) || 1) + 1); //progress along the bezier (value between 0 and 1)\n\t\t\t\t\tx1 = ax + (cp1x - ax) * t;\n\t\t\t\t\tx2 = cp1x + (cp2x - cp1x) * t;\n\t\t\t\t\tx1 += (x2 - x1) * t;\n\t\t\t\t\tx2 += ((cp2x + (bx - cp2x) * t) - x2) * t;\n\n\t\t\t\t\ty1 = ay + (cp1y - ay) * t;\n\t\t\t\t\ty2 = cp1y + (cp2y - cp1y) * t;\n\t\t\t\t\ty1 += (y2 - y1) * t;\n\t\t\t\t\ty2 += ((cp2y + (by - cp2y) * t) - y2) * t;\n\n\t\t\t\t\tsegment.splice(i, 4,\n\t\t\t\t\t\tax + (cp1x - ax) * t,   //first control point\n\t\t\t\t\t\tay + (cp1y - ay) * t,\n\t\t\t\t\t\tx1,                     //second control point\n\t\t\t\t\t\ty1,\n\t\t\t\t\t\tx1 + (x2 - x1) * t,     //new fabricated anchor on line\n\t\t\t\t\t\ty1 + (y2 - y1) * t,\n\t\t\t\t\t\tx2,                     //third control point\n\t\t\t\t\t\ty2,\n\t\t\t\t\t\tcp2x + (bx - cp2x) * t, //fourth control point\n\t\t\t\t\t\tcp2y + (by - cp2y) * t\n\t\t\t\t\t);\n\t\t\t\t\ti += 6;\n\t\t\t\t\tl += 6;\n\t\t\t\t\ttally--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn segment;\n\t\t},\n\t\t_rawPathToString = function(rawPath, precision) {\n\t\t\tvar s = \"\",\n\t\t\t\tspace = \" \",\n\t\t\t\tl = rawPath.length,\n\t\t\t\trnd = Math.pow(10, precision || 2),\n\t\t\t\ti, j, segment;\n\t\t\tfor (j = 0; j < rawPath.length; j++) {\n\t\t\t\tsegment = rawPath[j];\n\t\t\t\tl = segment.length;\n\t\t\t\ts += \"M\" + (((segment[0] * rnd) | 0) / rnd) + space + (((segment[1] * rnd) | 0) / rnd) + \" C\";\n\t\t\t\tfor (i = 2; i < l; i++) { //this is actually faster than just doing a join() on the array, possibly because the numbers have so many decimal places\n\t\t\t\t\ts += (((segment[i] * rnd) | 0) / rnd) + space;\n\t\t\t\t}\n\t\t\t\tif (segment.closed) {\n\t\t\t\t\ts += \"z\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s;\n\t\t},\n\t\t_reverseBezier = function(segment) {\n\t\t\tvar a = [],\n\t\t\t\ti = segment.length - 1,\n\t\t\t\tl = 0;\n\t\t\twhile (--i > -1) {\n\t\t\t\ta[l++] = segment[i];\n\t\t\t\ta[l++] = segment[i+1];\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tsegment[i] = a[i];\n\t\t\t}\n\t\t\tsegment.reversed = !segment.reversed;\n\t\t},\n\t\t_getAverageXY = function(segment) {\n\t\t\tvar l = segment.length,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0,\n\t\t\t\ti;\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tx += segment[i++];\n\t\t\t\ty += segment[i];\n\t\t\t}\n\t\t\treturn [x / (l / 2), y / (l / 2)];\n\t\t},\n\t\t_getSize = function(segment) { //rough estimate of the bounding box (based solely on the anchors) of a single segment. sets \"size\", \"centerX\", and \"centerY\" properties on the bezier array itself, and returns the size (width * height)\n\t\t\tvar l = segment.length,\n\t\t\t\txMax = segment[0],\n\t\t\t\txMin = xMax,\n\t\t\t\tyMax = segment[1],\n\t\t\t\tyMin = yMax,\n\t\t\t\tx, y, i;\n\t\t\tfor (i = 6; i < l; i+=6) {\n\t\t\t\tx = segment[i];\n\t\t\t\ty = segment[i+1];\n\t\t\t\tif (x > xMax) {\n\t\t\t\t\txMax = x;\n\t\t\t\t} else if (x < xMin) {\n\t\t\t\t\txMin = x;\n\t\t\t\t}\n\t\t\t\tif (y > yMax) {\n\t\t\t\t\tyMax = y;\n\t\t\t\t} else if (y < yMin) {\n\t\t\t\t\tyMin = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsegment.centerX = (xMax + xMin) / 2;\n\t\t\tsegment.centerY = (yMax + yMin) / 2;\n\t\t\treturn (segment.size = (xMax - xMin) * (yMax - yMin));\n\t\t},\n\t\t_getTotalSize = function(rawPath, samplesPerBezier) { //rough estimate of the bounding box of the entire list of Bezier segments (based solely on the anchors). sets \"size\", \"centerX\", and \"centerY\" properties on the bezier array itself, and returns the size (width * height)\n\t\t\tsamplesPerBezier = samplesPerBezier || 3;\n\t\t\tvar j = rawPath.length,\n\t\t\t\txMax = rawPath[0][0],\n\t\t\t\txMin = xMax,\n\t\t\t\tyMax = rawPath[0][1],\n\t\t\t\tyMin = yMax,\n\t\t\t\tinc = 1 / samplesPerBezier,\n\t\t\t\tl, x, y, i, segment, k, t, inv, x1, y1, x2, x3, x4, y2, y3, y4;\n\t\t\twhile (--j > -1) {\n\t\t\t\tsegment = rawPath[j];\n\t\t\t\tl = segment.length;\n\t\t\t\tfor (i = 6; i < l; i+=6) {\n\t\t\t\t\tx1 = segment[i];\n\t\t\t\t\ty1 = segment[i+1];\n\t\t\t\t\tx2 = segment[i+2] - x1;\n\t\t\t\t\ty2 = segment[i+3] - y1;\n\t\t\t\t\tx3 = segment[i+4] - x1;\n\t\t\t\t\ty3 = segment[i+5] - y1;\n\t\t\t\t\tx4 = segment[i+6] - x1;\n\t\t\t\t\ty4 = segment[i+7] - y1;\n\t\t\t\t\tk = samplesPerBezier;\n\t\t\t\t\twhile (--k > -1) {\n\t\t\t\t\t\tt = inc * k;\n\t\t\t\t\t\tinv = 1 - t;\n\t\t\t\t\t\tx = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t + x1;\n\t\t\t\t\t\ty = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t + y1;\n\t\t\t\t\t\tif (x > xMax) {\n\t\t\t\t\t\t\txMax = x;\n\t\t\t\t\t\t} else if (x < xMin) {\n\t\t\t\t\t\t\txMin = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (y > yMax) {\n\t\t\t\t\t\t\tyMax = y;\n\t\t\t\t\t\t} else if (y < yMin) {\n\t\t\t\t\t\t\tyMin = y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trawPath.centerX = (xMax + xMin) / 2;\n\t\t\trawPath.centerY = (yMax + yMin) / 2;\n\t\t\trawPath.left = xMin;\n\t\t\trawPath.width = (xMax - xMin);\n\t\t\trawPath.top = yMin;\n\t\t\trawPath.height = (yMax - yMin);\n\t\t\treturn (rawPath.size = (xMax - xMin) * (yMax - yMin));\n\t\t},\n\t\t_sortByComplexity = function(a, b) {\n\t\t\treturn b.length - a.length;\n\t\t},\n\t\t_sortBySize = function(a, b) {\n\t\t\tvar sizeA = a.size || _getSize(a),\n\t\t\t\tsizeB = b.size || _getSize(b);\n\t\t\treturn (Math.abs(sizeB - sizeA) < (sizeA + sizeB) / 20) ? (b.centerX - a.centerX) || (b.centerY - a.centerY) : sizeB - sizeA; //if the size is within 10% of each other, prioritize position from left to right, then top to bottom.\n\t\t},\n\t\t_offsetSegment = function(segment, shapeIndex) {\n\t\t\tvar a = segment.slice(0),\n\t\t\t\tl = segment.length,\n\t\t\t\twrap = l - 2,\n\t\t\t\ti, index;\n\t\t\tshapeIndex = shapeIndex | 0;\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tindex = (i + shapeIndex) % wrap;\n\t\t\t\tsegment[i++] = a[index];\n\t\t\t\tsegment[i] = a[index+1];\n\t\t\t}\n\t\t},\n\t\t_getTotalMovement = function(sb, eb, shapeIndex, offsetX, offsetY) {\n\t\t\tvar l = sb.length,\n\t\t\t\td = 0,\n\t\t\t\twrap = l - 2,\n\t\t\t\tindex, i, x, y;\n\t\t\tshapeIndex *= 6;\n\t\t\tfor (i = 0; i < l; i += 6) {\n\t\t\t\tindex = (i + shapeIndex) % wrap;\n\t\t\t\ty = sb[index] - (eb[i] - offsetX);\n\t\t\t\tx = sb[index+1] - (eb[i+1] - offsetY);\n\t\t\t\td += _sqrt(x * x + y * y);\n\t\t\t}\n\t\t\treturn d;\n\t\t},\n\t\t_getClosestShapeIndex = function(sb, eb, checkReverse) { //finds the index in a closed cubic bezier array that's closest to the angle provided (angle measured from the center or average x/y).\n\t\t\tvar l = sb.length,\n\t\t\t\tsCenter = _getAverageXY(sb), //when comparing distances, adjust the coordinates as if the shapes are centered with each other.\n\t\t\t\teCenter = _getAverageXY(eb),\n\t\t\t\toffsetX = eCenter[0] - sCenter[0],\n\t\t\t\toffsetY = eCenter[1] - sCenter[1],\n\t\t\t\tmin = _getTotalMovement(sb, eb, 0, offsetX, offsetY),\n\t\t\t\tminIndex = 0,\n\t\t\t\tcopy, d, i;\n\t\t\tfor (i = 6; i < l; i += 6) {\n\t\t\t\td = _getTotalMovement(sb, eb, i / 6, offsetX, offsetY);\n\t\t\t\tif (d < min) {\n\t\t\t\t\tmin = d;\n\t\t\t\t\tminIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (checkReverse) {\n\t\t\t\tcopy = sb.slice(0);\n\t\t\t\t_reverseBezier(copy);\n\t\t\t\tfor (i = 6; i < l; i += 6) {\n\t\t\t\t\td = _getTotalMovement(copy, eb, i / 6, offsetX, offsetY);\n\t\t\t\t\tif (d < min) {\n\t\t\t\t\t\tmin = d;\n\t\t\t\t\t\tminIndex = -i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn minIndex / 6;\n\t\t},\n\t\t_getClosestAnchor = function(rawPath, x, y) { //finds the x/y of the anchor that's closest to the provided x/y coordinate (returns an array, like [x, y]). The bezier should be the top-level type that contains an array for each segment.\n\t\t\tvar j = rawPath.length,\n\t\t\t\tclosestDistance = _bigNum,\n\t\t\t\tclosestX = 0,\n\t\t\t\tclosestY = 0,\n\t\t\t\tsegment, dx, dy, d, i, l;\n\t\t\twhile (--j > -1) {\n\t\t\t\tsegment = rawPath[j];\n\t\t\t\tl = segment.length;\n\t\t\t\tfor (i = 0; i < l; i += 6) {\n\t\t\t\t\tdx = segment[i] - x;\n\t\t\t\t\tdy = segment[i+1] - y;\n\t\t\t\t\td = _sqrt(dx * dx + dy * dy);\n\t\t\t\t\tif (d < closestDistance) {\n\t\t\t\t\t\tclosestDistance = d;\n\t\t\t\t\t\tclosestX = segment[i];\n\t\t\t\t\t\tclosestY = segment[i+1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn [closestX, closestY];\n\t\t},\n\t\t_getClosestSegment = function(bezier, pool, startIndex, sortRatio, offsetX, offsetY) { //matches the bezier to the closest one in a pool (array) of beziers, assuming they are in order of size and we shouldn't drop more than 20% of the size, otherwise prioritizing location (total distance to the center). Extracts the segment out of the pool array and returns it.\n\t\t\tvar l = pool.length,\n\t\t\t\tindex = 0,\n\t\t\t\tminSize = Math.min(bezier.size || _getSize(bezier), pool[startIndex].size || _getSize(pool[startIndex])) * sortRatio, //limit things based on a percentage of the size of either the bezier or the next element in the array, whichever is smaller.\n\t\t\t\tmin = _bigNum,\n\t\t\t\tcx = bezier.centerX + offsetX,\n\t\t\t\tcy = bezier.centerY + offsetY,\n\t\t\t\tsize, i, dx, dy, d;\n\t\t\tfor (i = startIndex; i < l; i++) {\n\t\t\t\tsize = pool[i].size || _getSize(pool[i]);\n\t\t\t\tif (size < minSize) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdx = pool[i].centerX - cx;\n\t\t\t\tdy = pool[i].centerY - cy;\n\t\t\t\td = _sqrt(dx * dx + dy * dy);\n\t\t\t\tif (d < min) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tmin = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = pool[index];\n\t\t\tpool.splice(index, 1);\n\t\t\treturn d;\n\t\t},\n\t\t_equalizeSegmentQuantity = function(start, end, shapeIndex, map, fillSafe) { //returns an array of shape indexes, 1 for each segment.\n\t\t\tvar dif = end.length - start.length,\n\t\t\t\tlonger = dif > 0 ? end : start,\n\t\t\t\tshorter = dif > 0 ? start : end,\n\t\t\t\tadded = 0,\n\t\t\t\tsortMethod = (map === \"complexity\") ? _sortByComplexity : _sortBySize,\n\t\t\t\tsortRatio = (map === \"position\") ? 0 : (typeof(map) === \"number\") ? map : 0.8,\n\t\t\t\ti = shorter.length,\n\t\t\t\tshapeIndices = (typeof(shapeIndex) === \"object\" && shapeIndex.push) ? shapeIndex.slice(0) : [shapeIndex],\n\t\t\t\treverse = (shapeIndices[0] === \"reverse\" || shapeIndices[0] < 0),\n\t\t\t\tlog = (shapeIndex === \"log\"),\n\t\t\t\teb, sb, b, x, y, offsetX, offsetY;\n\t\t\tif (!shorter[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (longer.length > 1) {\n\t\t\t\tstart.sort(sortMethod);\n\t\t\t\tend.sort(sortMethod);\n\t\t\t\toffsetX = longer.size || _getTotalSize(longer); //ensures centerX and centerY are defined (used below).\n\t\t\t\toffsetX = shorter.size || _getTotalSize(shorter);\n\t\t\t\toffsetX = longer.centerX - shorter.centerX;\n\t\t\t\toffsetY = longer.centerY - shorter.centerY;\n\t\t\t\tif (sortMethod === _sortBySize) {\n\t\t\t\t\tfor (i = 0; i < shorter.length; i++) {\n\t\t\t\t\t\tlonger.splice(i, 0, _getClosestSegment(shorter[i], longer, i, sortRatio, offsetX, offsetY));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dif) {\n\t\t\t\tif (dif < 0) {\n\t\t\t\t\tdif = -dif;\n\t\t\t\t}\n\t\t\t\tif (longer[0].length > shorter[0].length) { //since we use shorter[0] as the one to map the origination point of any brand new fabricated segments, do any subdividing first so that there are more points to choose from (if necessary)\n\t\t\t\t\t_subdivideSegment(shorter[0], ((longer[0].length - shorter[0].length)/6) | 0);\n\t\t\t\t}\n\t\t\t\ti = shorter.length;\n\t\t\t\twhile (added < dif) {\n\t\t\t\t\tx = longer[i].size || _getSize(longer[i]); //just to ensure centerX and centerY are calculated which we use on the next line.\n\t\t\t\t\tb = _getClosestAnchor(shorter, longer[i].centerX, longer[i].centerY);\n\t\t\t\t\tx = b[0];\n\t\t\t\t\ty = b[1];\n\t\t\t\t\tshorter[i++] = [x, y, x, y, x, y, x, y];\n\t\t\t\t\tshorter.totalPoints += 8;\n\t\t\t\t\tadded++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < start.length; i++) {\n\t\t\t\teb = end[i];\n\t\t\t\tsb = start[i];\n\t\t\t\tdif = eb.length - sb.length;\n\t\t\t\tif (dif < 0) {\n\t\t\t\t\t_subdivideSegment(eb, (-dif/6) | 0);\n\t\t\t\t} else if (dif > 0) {\n\t\t\t\t\t_subdivideSegment(sb, (dif/6) | 0);\n\t\t\t\t}\n\t\t\t\tif (reverse && fillSafe !== false && !sb.reversed) {\n\t\t\t\t\t_reverseBezier(sb);\n\t\t\t\t}\n\t\t\t\tshapeIndex = (shapeIndices[i] || shapeIndices[i] === 0) ? shapeIndices[i] : \"auto\";\n\t\t\t\tif (shapeIndex) {\n\t\t\t\t\t//if start shape is closed, find the closest point to the start/end, and re-organize the bezier points accordingly so that the shape morphs in a more intuitive way.\n\t\t\t\t\tif (sb.closed || (Math.abs(sb[0] - sb[sb.length - 2]) < 0.5 && Math.abs(sb[1] - sb[sb.length - 1]) < 0.5)) {\n\t\t\t\t\t\tif (shapeIndex === \"auto\" || shapeIndex === \"log\") {\n\t\t\t\t\t\t\tshapeIndices[i] = shapeIndex = _getClosestShapeIndex(sb, eb, (!i || fillSafe === false));\n\t\t\t\t\t\t\tif (shapeIndex < 0) {\n\t\t\t\t\t\t\t\treverse = true;\n\t\t\t\t\t\t\t\t_reverseBezier(sb);\n\t\t\t\t\t\t\t\tshapeIndex = -shapeIndex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_offsetSegment(sb, shapeIndex * 6);\n\n\t\t\t\t\t\t} else if (shapeIndex !== \"reverse\") {\n\t\t\t\t\t\t\tif (i && shapeIndex < 0) { //only happens if an array is passed as shapeIndex and a negative value is defined for an index beyond 0. Very rare, but helpful sometimes.\n\t\t\t\t\t\t\t\t_reverseBezier(sb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_offsetSegment(sb, (shapeIndex < 0 ? -shapeIndex : shapeIndex) * 6);\n\t\t\t\t\t\t}\n\t\t\t\t\t//otherwise, if it's not a closed shape, consider reversing it if that would make the overall travel less\n\t\t\t\t\t} else if (!reverse && (shapeIndex === \"auto\" && (Math.abs(eb[0] - sb[0]) + Math.abs(eb[1] - sb[1]) + Math.abs(eb[eb.length - 2] - sb[sb.length - 2]) + Math.abs(eb[eb.length - 1] - sb[sb.length - 1]) > Math.abs(eb[0] - sb[sb.length - 2]) + Math.abs(eb[1] - sb[sb.length - 1]) + Math.abs(eb[eb.length - 2] - sb[0]) + Math.abs(eb[eb.length - 1] - sb[1])) || (shapeIndex % 2))) {\n\t\t\t\t\t\t_reverseBezier(sb);\n\t\t\t\t\t\tshapeIndices[i] = -1;\n\t\t\t\t\t\treverse = true;\n\t\t\t\t\t} else if (shapeIndex === \"auto\") {\n\t\t\t\t\t\tshapeIndices[i] = 0;\n\t\t\t\t\t} else if (shapeIndex === \"reverse\") {\n\t\t\t\t\t\tshapeIndices[i] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (sb.closed !== eb.closed) { //if one is closed and one isn't, don't close either one otherwise the tweening will look weird (but remember, the beginning and final states will honor the actual values, so this only affects the inbetween state)\n\t\t\t\t\t\tsb.closed = eb.closed = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (log) {\n\t\t\t\t_log(\"shapeIndex:[\" + shapeIndices.join(\",\") + \"]\");\n\t\t\t}\n\t\t\tstart.shapeIndex = shapeIndices;\n\t\t\treturn shapeIndices;\n\t\t},\n\t\t_pathFilter = function(a, shapeIndex, map, precompile, fillSafe) {\n\t\t\tvar start = _stringToRawPath(a[0]),\n\t\t\t\tend = _stringToRawPath(a[1]);\n\t\t\tif (!_equalizeSegmentQuantity(start, end, (shapeIndex || shapeIndex === 0) ? shapeIndex : \"auto\", map, fillSafe)) {\n\t\t\t\treturn; //malformed path data or null target\n\t\t\t}\n\t\t\ta[0] = _rawPathToString(start);\n\t\t\ta[1] = _rawPathToString(end);\n\t\t\tif (precompile === \"log\" || precompile === true) {\n\t\t\t\t_log('precompile:[\"' + a[0] + '\",\"' + a[1] + '\"]');\n\t\t\t}\n\t\t},\n\t\t/*\n\t\t_buildPathFilter = function(shapeIndex, map, precompile) {\n\t\t\treturn (map || precompile || shapeIndex || shapeIndex === 0) ? function(a) {\n\t\t\t\t_pathFilter(a, shapeIndex, map, precompile);\n\t\t\t} : _pathFilter;\n\t\t},\n\t\t*/\n\t\t_offsetPoints = function(text, offset) {\n\t\t\tif (!offset) {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t\tvar a = text.match(_numbersExp) || [],\n\t\t\t\tl = a.length,\n\t\t\t\ts = \"\",\n\t\t\t\tinc, i, j;\n\t\t\tif (offset === \"reverse\") {\n\t\t\t\ti = l-1;\n\t\t\t\tinc = -2;\n\t\t\t} else {\n\t\t\t\ti = (((parseInt(offset, 10) || 0) * 2 + 1) + l * 100) % l;\n\t\t\t\tinc = 2;\n\t\t\t}\n\t\t\tfor (j = 0; j < l; j += 2) {\n\t\t\t\ts += a[i-1] + \",\" + a[i] + \" \";\n\t\t\t\ti = (i + inc) % l;\n\t\t\t}\n\t\t\treturn s;\n\t\t},\n\t\t//adds a certain number of points while maintaining the polygon/polyline shape (so that the start/end values can have a matching quantity of points to animate). Returns the revised string.\n\t\t_equalizePointQuantity = function(a, quantity) {\n\t\t\tvar tally = 0,\n\t\t\t\tx = parseFloat(a[0]),\n\t\t\t\ty = parseFloat(a[1]),\n\t\t\t\ts = x + \",\" + y + \" \",\n\t\t\t\tmax = 0.999999,\n\t\t\t\tnewPointsPerSegment, i, l, j, factor, nextX, nextY;\n\t\t\tl = a.length;\n\t\t\tnewPointsPerSegment = quantity * 0.5 / (l * 0.5 - 1);\n\t\t\tfor (i = 0; i < l-2; i += 2) {\n\t\t\t\ttally += newPointsPerSegment;\n\t\t\t\tnextX = parseFloat(a[i+2]);\n\t\t\t\tnextY = parseFloat(a[i+3]);\n\t\t\t\tif (tally > max) { //compare with 0.99999 instead of 1 in order to prevent rounding errors\n\t\t\t\t\tfactor = 1 / (Math.floor(tally) + 1);\n\t\t\t\t\tj = 1;\n\t\t\t\t\twhile (tally > max) {\n\t\t\t\t\t\ts += (x + (nextX - x) * factor * j).toFixed(2) + \",\" + (y + (nextY - y) * factor * j).toFixed(2) + \" \";\n\t\t\t\t\t\ttally--;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts += nextX + \",\" + nextY + \" \";\n\t\t\t\tx = nextX;\n\t\t\t\ty = nextY;\n\t\t\t}\n\t\t\treturn s;\n\t\t},\n\t\t_pointsFilter = function(a) {\n\t\t\tvar startNums = a[0].match(_numbersExp) || [],\n\t\t\t\tendNums = a[1].match(_numbersExp) || [],\n\t\t\t\tdif = endNums.length - startNums.length;\n\t\t\tif (dif > 0) {\n\t\t\t\ta[0] = _equalizePointQuantity(startNums, dif);\n\t\t\t} else {\n\t\t\t\ta[1] = _equalizePointQuantity(endNums, -dif);\n\t\t\t}\n\t\t},\n\t\t_buildPointsFilter = function(shapeIndex) {\n\t\t\treturn !isNaN(shapeIndex) ? function(a) {\n\t\t\t\t_pointsFilter(a);\n\t\t\t\ta[1] = _offsetPoints(a[1], parseInt(shapeIndex, 10));\n\t\t\t} : _pointsFilter;\n\t\t},\n\t\t_createPath = function(e, ignore) {\n\t\t\tvar path = _gsScope.document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\"),\n\t\t\t\tattr = Array.prototype.slice.call(e.attributes),\n\t\t\t\ti = attr.length,\n\t\t\t\tname;\n\t\t\tignore = \",\" + ignore + \",\";\n\t\t\twhile (--i > -1) {\n\t\t\t\tname = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.\n\t\t\t\tif (ignore.indexOf(\",\" + name + \",\") === -1) {\n\t\t\t\t\tpath.setAttributeNS(null, name, attr[i].nodeValue);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn path;\n\t\t},\n\t\t_typeAttrs = {\n\t\t\trect:\"rx,ry,x,y,width,height\",\n\t\t\tcircle:\"r,cx,cy\",\n\t\t\tellipse:\"rx,ry,cx,cy\",\n\t\t\tline:\"x1,x2,y1,y2\"\n\t\t},\n\t\t_attrToObj = function(e, attrs) {\n\t\t\tvar props = attrs ? attrs.split(\",\") : [],\n\t\t\t\tobj = {},\n\t\t\t\ti = props.length;\n\t\t\twhile (--i > -1) {\n\t\t\t\tobj[props[i]] = +e.getAttribute(props[i]) || 0;\n\t\t\t}\n\t\t\treturn obj;\n\t\t},\n\t\t_convertToPath = function(e, swap) {\n\t\t\tvar type = e.tagName.toLowerCase(),\n\t\t\t\tcirc = 0.552284749831,\n\t\t\t\tdata, x, y, r, ry, path, rcirc, rycirc, points, w, h, x2, x3, x4, x5, x6, y2, y3, y4, y5, y6, attr;\n\t\t\tif (type === \"path\" || !e.getBBox) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tpath = _createPath(e, \"x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points\");\n\t\t\tattr = _attrToObj(e, _typeAttrs[type]);\n\t\t\tif (type === \"rect\") {\n\t\t\t\tr = attr.rx;\n\t\t\t\try = attr.ry;\n\t\t\t\tx = attr.x;\n\t\t\t\ty = attr.y;\n\t\t\t\tw = attr.width - r * 2;\n\t\t\t\th = attr.height - ry * 2;\n\t\t\t\tif (r || ry) { //if there are rounded corners, render cubic beziers\n\t\t\t\t\tx2 = x + r * (1 - circ);\n\t\t\t\t\tx3 = x + r;\n\t\t\t\t\tx4 = x3 + w;\n\t\t\t\t\tx5 = x4 + r * circ;\n\t\t\t\t\tx6 = x4 + r;\n\t\t\t\t\ty2 = y + ry * (1 - circ);\n\t\t\t\t\ty3 = y + ry;\n\t\t\t\t\ty4 = y3 + h;\n\t\t\t\t\ty5 = y4 + ry * circ;\n\t\t\t\t\ty6 = y4 + ry;\n\t\t\t\t\tdata = \"M\" + x6 + \",\" + y3 + \" V\" + y4 + \" C\" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(\",\") + \"z\";\n\t\t\t\t} else {\n\t\t\t\t\tdata = \"M\" + (x + w) + \",\" + y + \" v\" + h + \" h\" + (-w) + \" v\" + (-h) + \" h\" + w + \"z\";\n\t\t\t\t}\n\n\t\t\t} else if (type === \"circle\" || type === \"ellipse\") {\n\t\t\t\tif (type === \"circle\") {\n\t\t\t\t\tr = ry = attr.r;\n\t\t\t\t\trycirc = r * circ;\n\t\t\t\t} else {\n\t\t\t\t\tr = attr.rx;\n\t\t\t\t\try = attr.ry;\n\t\t\t\t\trycirc = ry * circ;\n\t\t\t\t}\n\t\t\t\tx = attr.cx;\n\t\t\t\ty = attr.cy;\n\t\t\t\trcirc = r * circ;\n\t\t\t\tdata = \"M\" + (x+r) + \",\" + y + \" C\" + [x+r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(\",\") + \"z\";\n\t\t\t} else if (type === \"line\") {\n\t\t\t\tdata = \"M\" + attr.x1 + \",\" + attr.y1 + \" L\" + attr.x2 + \",\" + attr.y2; //previously, we just converted to \"Mx,y Lx,y\" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.\n\t\t\t} else if (type === \"polyline\" || type === \"polygon\") {\n\t\t\t\tpoints = (e.getAttribute(\"points\") + \"\").match(_numbersExp) || [];\n\t\t\t\tx = points.shift();\n\t\t\t\ty = points.shift();\n\t\t\t\tdata = \"M\" + x + \",\" + y + \" L\" + points.join(\",\");\n\t\t\t\tif (type === \"polygon\") {\n\t\t\t\t\tdata += \",\" + x + \",\" + y + \"z\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tpath.setAttribute(\"d\", _rawPathToString(path._gsRawPath = _stringToRawPath(data)));\n\t\t\tif (swap && e.parentNode) {\n\t\t\t\te.parentNode.insertBefore(path, e);\n\t\t\t\te.parentNode.removeChild(e);\n\t\t\t}\n\n\t\t\treturn path;\n\t\t},\n\t\t_parseShape = function(shape, forcePath, target) {\n\t\t\tvar isString = typeof(shape) === \"string\",\n\t\t\t\te, type;\n\t\t\tif (!isString || _selectorExp.test(shape) || (shape.match(_numbersExp) || []).length < 3) {\n\t\t\t\te = isString ? TweenLite.selector(shape) : (shape && shape[0]) ? shape : [shape]; //allow array-like objects like jQuery objects.\n\t\t\t\tif (e && e[0]) {\n\t\t\t\t\te = e[0];\n\t\t\t\t\ttype = (e.nodeName + \"\").toUpperCase();\n\t\t\t\t\tif (forcePath && type !== \"PATH\") { //if we were passed an element (or selector text for an element) that isn't a path, convert it.\n\t\t\t\t\t\te = _convertToPath(e, false);\n\t\t\t\t\t\ttype = \"PATH\";\n\t\t\t\t\t}\n\t\t\t\t\tshape = e.getAttribute(type === \"PATH\" ? \"d\" : \"points\") || \"\";\n\t\t\t\t\tif (e === target) { //if the shape matches the target element, the user wants to revert to the original which should have been stored in the data-original attribute\n\t\t\t\t\t\tshape = e.getAttributeNS(null, \"data-original\") || shape;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t_log(\"WARNING: invalid morph to: \" + shape);\n\t\t\t\t\tshape = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn shape;\n\t\t},\n\t\t//adds an \"isSmooth\" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.\n\t\t_populateSmoothData = function(rawPath, tolerance) {\n\t\t\tvar j = rawPath.length,\n\t\t\t\tlimit = 0.2 * (tolerance || 1),\n\t\t\t\tsmooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;\n\t\t\twhile (--j > -1) {\n\t\t\t\tsegment = rawPath[j];\n\t\t\t\tisSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];\n\t\t\t\tsmoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];\n\t\t\t\tisSmooth.length = 4;\n\t\t\t\tl = segment.length - 2;\n\t\t\t\tfor (i = 6; i < l; i += 6) {\n\t\t\t\t\tx = segment[i] - segment[i - 2];\n\t\t\t\t\ty = segment[i + 1] - segment[i - 1];\n\t\t\t\t\tx2 = segment[i + 2] - segment[i];\n\t\t\t\t\ty2 = segment[i + 3] - segment[i + 1];\n\t\t\t\t\ta = _atan2(y, x);\n\t\t\t\t\ta2 = _atan2(y2, x2);\n\t\t\t\t\tsmooth = (Math.abs(a - a2) < limit);\n\t\t\t\t\tif (smooth) {\n\t\t\t\t\t\tsmoothData[i - 2] = a;\n\t\t\t\t\t\tsmoothData[i + 2] = a2;\n\t\t\t\t\t\tsmoothData[i - 1] = _sqrt(x * x + y * y);\n\t\t\t\t\t\tsmoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t\t\t}\n\t\t\t\t\tisSmooth.push(smooth, smooth, 0, 0, smooth, smooth);\n\t\t\t\t}\n\t\t\t\t//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.\n\t\t\t\tif (segment[l] === segment[0] && segment[l+1] === segment[1]) {\n\t\t\t\t\tx = segment[0] - segment[l-2];\n\t\t\t\t\ty = segment[1] - segment[l-1];\n\t\t\t\t\tx2 = segment[2] - segment[0];\n\t\t\t\t\ty2 = segment[3] - segment[1];\n\t\t\t\t\ta = _atan2(y, x);\n\t\t\t\t\ta2 = _atan2(y2, x2);\n\t\t\t\t\tif (Math.abs(a - a2) < limit) {\n\t\t\t\t\t\tsmoothData[l-2] = a;\n\t\t\t\t\t\tsmoothData[2] = a2;\n\t\t\t\t\t\tsmoothData[l-1] = _sqrt(x * x + y * y);\n\t\t\t\t\t\tsmoothData[3] = _sqrt(x2 * x2 + y2 * y2);\n\t\t\t\t\t\tisSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rawPath;\n\t\t},\n\t\t_parseOriginFactors = function(v) {\n\t\t\tvar a = v.trim().split(\" \"),\n\t\t\t\tx = (v.indexOf(\"left\") >= 0) ? 0 : (v.indexOf(\"right\") >= 0) ? 100 : isNaN(parseFloat(a[0])) ? 50 : parseFloat(a[0]),\n\t\t\t\ty = (v.indexOf(\"top\") >= 0) ? 0 : (v.indexOf(\"bottom\") >= 0) ? 100 : isNaN(parseFloat(a[1])) ? 50 : parseFloat(a[1]);\n\t\t\treturn {x:x / 100, y:y / 100};\n\t\t},\n\t\t_shortAngle = function(dif) {\n\t\t\treturn (dif !== dif % _PI) ? dif + ((dif < 0) ? _2PI : -_2PI) : dif;\n\t\t},\n\t\t_morphMessage = \"Use MorphSVGPlugin.convertToPath(elementOrSelectorText) to convert to a path before morphing.\",\n\n\n\n\t\tMorphSVGPlugin = _gsScope._gsDefine.plugin({\n\t\t\tpropName: \"morphSVG\",\n\t\t\tAPI: 2,\n\t\t\tglobal: true,\n\t\t\tversion: \"0.9.2\",\n\n\t\t\t//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.\n\t\t\tinit: function(target, value, tween, index) {\n\t\t\t\tvar cs = target.nodeType ? window.getComputedStyle(target) : {},\n\t\t\t\t\tfill = cs.fill + \"\",\n\t\t\t\t\tfillSafe = !(fill === \"none\" || (fill.match(_numbersExp) || [])[3] === \"0\" || cs.fillRule === \"evenodd\"),\n\t\t\t\t\torigins = (value.origin || \"50 50\").split(\",\"),\n\t\t\t\t\ttype, p, pt, shape, isPoly, shapeIndex, map, startSmooth, endSmooth, start, end, i, j, l, startSeg, endSeg, precompiled, sData, eData, originFactors, useRotation, offset;\n\t\t\t\tif (typeof(value) === \"function\") {\n\t\t\t\t\tvalue = value(index, target);\n\t\t\t\t}\n\t\t\t\ttype = (target.nodeName + \"\").toUpperCase();\n\t\t\t\tisPoly = (type === \"POLYLINE\" || type === \"POLYGON\");\n\t\t\t\tif (type !== \"PATH\" && !isPoly && !value.prop) {\n\t\t\t\t\t_log(\"WARNING: cannot morph a <\" + type + \"> element. \" + _morphMessage);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tp = (type === \"PATH\") ? \"d\" : \"points\";\n\t\t\t\tif (typeof(value) === \"string\" || value.getBBox || value[0]) {\n\t\t\t\t\tvalue = {shape:value};\n\t\t\t\t}\n\t\t\t\tif (!value.prop && typeof(target.setAttribute) !== \"function\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tshape = _parseShape(value.shape || value.d || value.points || \"\", (p === \"d\"), target);\n\t\t\t\tif (isPoly && _commands.test(shape)) {\n\t\t\t\t\t_log(\"WARNING: a <\" + type + \"> cannot accept path data. \" + _morphMessage);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tshapeIndex = (value.shapeIndex || value.shapeIndex === 0) ? value.shapeIndex : \"auto\";\n\t\t\t\tmap = value.map || MorphSVGPlugin.defaultMap;\n\t\t\t\tthis._prop = value.prop;\n\t\t\t\tthis._render = value.render || MorphSVGPlugin.defaultRender;\n\t\t\t\tthis._apply = (\"updateTarget\" in value) ? value.updateTarget : MorphSVGPlugin.defaultUpdateTarget;\n\t\t\t\tthis._rnd = Math.pow(10, isNaN(value.precision) ? 2 : +value.precision);\n\t\t\t\tthis._tween = tween;\n\t\t\t\tif (shape) {\n\t\t\t\t\tthis._target = target;\n\t\t\t\t\tprecompiled = (typeof(value.precompile) === \"object\");\n\t\t\t\t\tstart = this._prop ? target[this._prop] : target.getAttribute(p);\n\t\t\t\t\tif (!this._prop && !target.getAttributeNS(null, \"data-original\")) {\n\t\t\t\t\t\ttarget.setAttributeNS(null, \"data-original\", start); //record the original state in a data-original attribute so that we can revert to it later.\n\t\t\t\t\t}\n\t\t\t\t\tif (p === \"d\" || this._prop) {\n\t\t\t\t\t\tstart = _stringToRawPath(precompiled ? value.precompile[0] : start);\n\t\t\t\t\t\tend = _stringToRawPath(precompiled ? value.precompile[1] : shape);\n\t\t\t\t\t\tif (!precompiled && !_equalizeSegmentQuantity(start, end, shapeIndex, map, fillSafe)) {\n\t\t\t\t\t\t\treturn false; //malformed path data or null target\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.precompile === \"log\" || value.precompile === true) {\n\t\t\t\t\t\t\t_log('precompile:[\"' + _rawPathToString(start) + '\",\"' + _rawPathToString(end) + '\"]');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuseRotation = (value.type || MorphSVGPlugin.defaultType) !== \"linear\";\n\n\t\t\t\t\t\tif (useRotation) {\n\t\t\t\t\t\t\tstart = _populateSmoothData(start, value.smoothTolerance);\n\t\t\t\t\t\t\tend = _populateSmoothData(end, value.smoothTolerance   );\n\t\t\t\t\t\t\tif (!start.size) {\n\t\t\t\t\t\t\t\t_getTotalSize(start); //adds top/left/width/height values\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!end.size) {\n\t\t\t\t\t\t\t\t_getTotalSize(end);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\toriginFactors = _parseOriginFactors(origins[0]);\n\t\t\t\t\t\t\tthis._origin = start.origin = {x:start.left + originFactors.x * start.width, y:start.top + originFactors.y * start.height};\n\t\t\t\t\t\t\tif (origins[1]) {\n\t\t\t\t\t\t\t\toriginFactors = _parseOriginFactors(origins[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._eOrigin = {x:end.left + originFactors.x * end.width, y:end.top + originFactors.y * end.height};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._rawPath = target._gsRawPath =  start;\n\n\t\t\t\t\t\tj = start.length;\n\t\t\t\t\t\twhile (--j > -1) {\n\t\t\t\t\t\t\tstartSeg = start[j];\n\t\t\t\t\t\t\tendSeg = end[j];\n\t\t\t\t\t\t\tstartSmooth = startSeg.isSmooth || [];\n\t\t\t\t\t\t\tendSmooth = endSeg.isSmooth || [];\n\t\t\t\t\t\t\tl = startSeg.length;\n\t\t\t\t\t\t\t_lastLinkedAnchor = 0; //reset; we use _lastLinkedAnchor in the _tweenRotation() method to help make sure that close points don't get ripped apart and rotate opposite directions. Typically we want to go the shortest direction, but if the previous anchor is going a different direction, we override this logic (within certain thresholds)\n\t\t\t\t\t\t\tfor (i = 0; i < l; i+=2) {\n\t\t\t\t\t\t\t\tif (endSeg[i] !== startSeg[i] || endSeg[i+1] !== startSeg[i+1]) {\n\t\t\t\t\t\t\t\t\tif (useRotation) {\n\t\t\t\t\t\t\t\t\t\tif (startSmooth[i] && endSmooth[i]) { //if BOTH starting and ending values are smooth (meaning control points have basically the same slope), interpolate the rotation and length instead of the coordinates (this is what makes things smooth).\n\t\t\t\t\t\t\t\t\t\t\tsData = startSeg.smoothData;\n\t\t\t\t\t\t\t\t\t\t\teData = endSeg.smoothData;\n\t\t\t\t\t\t\t\t\t\t\toffset = i + ((i === l - 4) ? 7 - l : 5); //helps us accommodate wrapping (like if the end and start anchors are identical and the control points are smooth).\n\t\t\t\t\t\t\t\t\t\t\tthis._controlPT = {_next:this._controlPT, i:i, j:j, l1s:sData[i+1], l1c:eData[i+1] - sData[i+1], l2s:sData[offset], l2c:eData[offset] - sData[offset]};\n\t\t\t\t\t\t\t\t\t\t\tpt = this._tweenRotation(startSeg, endSeg, i+2);\n\t\t\t\t\t\t\t\t\t\t\tthis._tweenRotation(startSeg, endSeg, i, pt);\n\t\t\t\t\t\t\t\t\t\t\tthis._tweenRotation(startSeg, endSeg, offset-1, pt);\n\t\t\t\t\t\t\t\t\t\t\ti+=4;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tthis._tweenRotation(startSeg, endSeg, i);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpt = this._addTween(startSeg, i, startSeg[i], endSeg[i]);\n\t\t\t\t\t\t\t\t\t\tpt = this._addTween(startSeg, i+1, startSeg[i+1], endSeg[i+1]) || pt;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpt = this._addTween(target, \"setAttribute\", target.getAttribute(p) + \"\", shape + \"\", \"morphSVG\", false, p, _buildPointsFilter(shapeIndex));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useRotation) {\n\t\t\t\t\t\tthis._addTween(this._origin, \"x\", this._origin.x, this._eOrigin.x);\n\t\t\t\t\t\tpt = this._addTween(this._origin, \"y\", this._origin.y, this._eOrigin.y);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (pt) {\n\t\t\t\t\t\tthis._overwriteProps.push(\"morphSVG\");\n\t\t\t\t\t\tpt.end = shape;\n\t\t\t\t\t\tpt.endProp = p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\tset: function(ratio) {\n\t\t\t\tvar rawPath = this._rawPath,\n\t\t\t\t\tcontrolPT = this._controlPT,\n\t\t\t\t\tanchorPT = this._anchorPT,\n\t\t\t\t\trnd = this._rnd,\n\t\t\t\t\ttarget = this._target,\n\t\t\t\t\ts, space, easeInOut, pt, segment, l, angle, i, j, x, y, sin, cos, offset;\n\t\t\t\tthis._super.setRatio.call(this, ratio);\n\t\t\t\tif (ratio === 1 && this._apply) {\n\t\t\t\t\tpt = this._firstPT;\n\t\t\t\t\twhile (pt) {\n\t\t\t\t\t\tif (pt.end) {\n\t\t\t\t\t\t\tif (this._prop) {\n\t\t\t\t\t\t\t\ttarget[this._prop] = pt.end;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.setAttribute(pt.endProp, pt.end); //make sure the end value is exactly as specified (in case we had to add fabricated points during the tween)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpt = pt._next;\n\t\t\t\t\t}\n\t\t\t\t} else if (rawPath) {\n\n\t\t\t\t\t//rotationally position the anchors\n\t\t\t\t\twhile (anchorPT) {\n\t\t\t\t\t\tangle = anchorPT.sa + ratio * anchorPT.ca;\n\t\t\t\t\t\tl = anchorPT.sl + ratio * anchorPT.cl;    //length\n\t\t\t\t\t\tanchorPT.t[anchorPT.i] = this._origin.x + _cos(angle) * l;\n\t\t\t\t\t\tanchorPT.t[anchorPT.i + 1] = this._origin.y + _sin(angle) * l;\n\t\t\t\t\t\tanchorPT = anchorPT._next;\n\t\t\t\t\t}\n\n\t\t\t\t\t//smooth out the control points\n\t\t\t\t\teaseInOut = ratio < 0.5 ? 2 * ratio * ratio : (4 - 2 * ratio) * ratio - 1;\n\t\t\t\t\twhile (controlPT) {\n\t\t\t\t\t\ti = controlPT.i;\n\t\t\t\t\t\tsegment = rawPath[controlPT.j];\n\t\t\t\t\t\toffset = i + ((i === segment.length - 4) ? 7 - segment.length : 5); //accommodates wrapping around of smooth points, like if the start and end anchors are on top of each other and their handles are smooth.\n\t\t\t\t\t\tangle = _atan2(segment[offset] - segment[i+1], segment[offset-1] - segment[i]); //average the angles\n\t\t\t\t\t\tsin = _sin(angle);\n\t\t\t\t\t\tcos = _cos(angle);\n\t\t\t\t\t\tx = segment[i+2];\n\t\t\t\t\t\ty = segment[i+3];\n\t\t\t\t\t\tl = controlPT.l1s + easeInOut * controlPT.l1c;    //length\n\t\t\t\t\t\tsegment[i] = x - cos * l;\n\t\t\t\t\t\tsegment[i+1] = y - sin * l;\n\t\t\t\t\t\tl = controlPT.l2s + easeInOut * controlPT.l2c;\n\t\t\t\t\t\tsegment[offset-1] = x + cos * l;\n\t\t\t\t\t\tsegment[offset] = y + sin * l;\n\t\t\t\t\t\tcontrolPT = controlPT._next;\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget._gsRawPath = rawPath;\n\n\t\t\t\t\tif (this._apply) {\n\t\t\t\t\t\ts = \"\";\n\t\t\t\t\t\tspace = \" \";\n\t\t\t\t\t\tfor (j = 0; j < rawPath.length; j++) {\n\t\t\t\t\t\t\tsegment = rawPath[j];\n\t\t\t\t\t\t\tl = segment.length;\n\t\t\t\t\t\t\ts += \"M\" + (((segment[0] * rnd) | 0) / rnd) + space + (((segment[1] * rnd) | 0) / rnd) + \" C\";\n\t\t\t\t\t\t\tfor (i = 2; i < l; i++) { //this is actually faster than just doing a join() on the array, possibly because the numbers have so many decimal places\n\t\t\t\t\t\t\t\ts += (((segment[i] * rnd) | 0) / rnd) + space;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this._prop) {\n\t\t\t\t\t\t\ttarget[this._prop] = s;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.setAttribute(\"d\", s);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this._render && rawPath) {\n\t\t\t\t\tthis._render.call(this._tween, rawPath, target);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\tMorphSVGPlugin.prototype._tweenRotation = function(start, end, i, linkedPT) {\n\t\tvar so = this._origin,              //starting origin\n\t\t\teo = this._eOrigin,             //ending origin\n\t\t\tdx = start[i] - so.x,\n\t\t\tdy = start[i+1] - so.y,\n\t\t\td = _sqrt(dx * dx + dy * dy),   //length from starting origin to starting point\n\t\t\tsa = _atan2(dy, dx),\n\t\t\tangleDif, short;\n\t\tdx = end[i] - eo.x;\n\t\tdy = end[i+1] - eo.y;\n\t\tangleDif = _atan2(dy, dx) - sa;\n\t\tshort = _shortAngle(angleDif);\n\t\t//in the case of control points, we ALWAYS link them to their anchor so that they don't get torn apart and rotate the opposite direction. If it's not a control point, we look at the most recently linked point as long as they're within a certain rotational range of each other.\n\t\tif (!linkedPT && _lastLinkedAnchor && Math.abs(short + _lastLinkedAnchor.ca) < _angleMin) {\n\t\t\tlinkedPT = _lastLinkedAnchor;\n\t\t}\n\t\treturn (this._anchorPT = _lastLinkedAnchor = {\n\t\t\t_next:this._anchorPT,\n\t\t\tt:start,\n\t\t\tsa:sa,                              //starting angle\n\t\t\tca:(linkedPT && short * linkedPT.ca < 0 && Math.abs(short) > _angleMax) ? angleDif : short,  //change in angle\n\t\t\tsl:d,                               //starting length\n\t\t\tcl:_sqrt(dx * dx + dy * dy) - d,    //change in length\n\t\t\ti:i\n\t\t});\n\t};\n\n\tMorphSVGPlugin.pathFilter = _pathFilter;\n\tMorphSVGPlugin.pointsFilter = _pointsFilter;\n\tMorphSVGPlugin.getTotalSize = _getTotalSize;\n\tMorphSVGPlugin.subdivideRawBezier = MorphSVGPlugin.subdivideSegment = _subdivideSegment;\n\tMorphSVGPlugin.rawPathToString = _rawPathToString;\n\tMorphSVGPlugin.defaultType = \"linear\";\n\tMorphSVGPlugin.defaultUpdateTarget = true;\n\tMorphSVGPlugin.defaultMap = \"size\";\n\tMorphSVGPlugin.stringToRawPath = MorphSVGPlugin.pathDataToRawBezier = function(data) {\n\t\treturn _stringToRawPath(_parseShape(data, true));\n\t};\n\tMorphSVGPlugin.equalizeSegmentQuantity = _equalizeSegmentQuantity;\n\n\tMorphSVGPlugin.convertToPath = function(targets, swap) {\n\t\tif (typeof(targets) === \"string\") {\n\t\t\ttargets = TweenLite.selector(targets);\n\t\t}\n\t\tvar a = (!targets || targets.length === 0) ? [] : (targets.length && targets[0] && targets[0].nodeType) ? Array.prototype.slice.call(targets, 0) : [targets],\n\t\t\ti = a.length;\n\t\twhile (--i > -1) {\n\t\t\ta[i] = _convertToPath(a[i], (swap !== false));\n\t\t}\n\t\treturn a;\n\t};\n\n\tMorphSVGPlugin.pathDataToBezier = function(data, vars) { //converts SVG path data into an array of {x, y} objects that can be plugged directly into a bezier tween. You can optionally pass in a 2D matrix like [a, b, c, d, tx, ty] containing numbers that should transform each point.\n\t\tvar bezier = _stringToRawPath(_parseShape(data, true))[0] || [],\n\t\t\tprefix = 0,\n\t\t\ta, i, l, matrix, offsetX, offsetY, bbox, e;\n\t\tvars = vars || {};\n\t\te = vars.align || vars.relative;\n\t\tmatrix = vars.matrix || [1,0,0,1,0,0];\n\t\toffsetX = vars.offsetX || 0;\n\t\toffsetY = vars.offsetY || 0;\n\t\tif (e === \"relative\" || e === true) {\n\t\t\toffsetX -= bezier[0] * matrix[0] + bezier[1] * matrix[2];\n\t\t\toffsetY -= bezier[0] * matrix[1] + bezier[1] * matrix[3];\n\t\t\tprefix = \"+=\";\n\t\t} else {\n\t\t\toffsetX += matrix[4];\n\t\t\toffsetY += matrix[5];\n\t\t\tif (e) {\n\t\t\t\te = (typeof(e) === \"string\") ? TweenLite.selector(e) : (e && e[0]) ? e : [e]; //allow array-like objects like jQuery objects.\n\t\t\t\tif (e && e[0]) {\n\t\t\t\t\tbbox = e[0].getBBox() || {x:0, y:0};\n\t\t\t\t\toffsetX -= bbox.x;\n\t\t\t\t\toffsetY -= bbox.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta = [];\n\t\tl = bezier.length;\n\t\tif (matrix && matrix.join(\",\") !== \"1,0,0,1,0,0\") {\n\t\t\tfor (i = 0; i < l; i+=2) {\n\t\t\t\ta.push({x:prefix + (bezier[i] * matrix[0] + bezier[i+1] * matrix[2] + offsetX), y:prefix + (bezier[i] * matrix[1] + bezier[i+1] * matrix[3] + offsetY)});\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < l; i+=2) {\n\t\t\t\ta.push({x:prefix + (bezier[i] + offsetX), y:prefix + (bezier[i+1] + offsetY)});\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t};\n\n\n\nexport { MorphSVGPlugin, MorphSVGPlugin as default };"],"sourceRoot":""}